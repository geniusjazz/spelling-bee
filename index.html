<!DOCTYPE html>
<html>
<head>
  <title>Spelling Bee Adventure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      font-family: 'Comic Neue', cursive !important;
    }

    body {
      text-align: center;
      padding: 20px;
      background: url('https://subtlepatterns.com/patterns/honey_im_subtle.png') #fff9e6;
      margin: 0;
      color: #333;
      min-height: 100vh;
    }

    #header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background: rgba(255, 235, 59, 0.7);
      border-bottom: 3px solid #f06292;
      margin-bottom: 20px;
    }

    #pronounce-toggle button {
      padding: 8px 15px;
      font-size: 16px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: background 0.3s;
    }

    #pronounce-toggle button.off {
      background: #f44336;
    }

    #wordListButton,
    #resetButton {
      width: 120px;
      background: #9c27b0;
      padding: 10px 15px;
      font-size: 16px;
      opacity: 0.7;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    #resetButton {
      background: #f44336;
    }

    #wordListButton:hover,
    #resetButton:hover {
      opacity: 1;
    }

    h1 {
      font-size: 48px;
      color: #e91e63;
      text-shadow: 2px 2px #ffeb3b;
      animation: bounce 2s infinite;
      margin-top: 20px;
    }

    #progress {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 20px 0;
      height: 40px;
    }

    .bee {
      width: 40px;
      height: 40px;
      background: url('https://img.icons8.com/ios-filled/50/ffeb3b/bee.png') no-repeat center;
      background-size: contain;
      margin-left: 10px;
    }

    #progress-bar-container {
      width: 90%;
      max-width: 400px;
      height: 20px;
      background: #ccc;
      border-radius: 10px;
      overflow: hidden;
      margin: 0 auto 10px auto;
    }

    #progress-bar {
      height: 100%;
      background: #4caf50;
      width: 0%;
      transition: width 0.5s ease;
    }

    #progress-text {
      font-size: 20px;
      color: #d81b60;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #part,
    #definition,
    #wordIndex {
      font-size: 24px;
      margin: 15px 0;
      color: #d81b60;
      background: rgba(255, 235, 59, 0.7);
      padding: 10px;
      border-radius: 15px;
      display: inline-block;
    }

    #wordDisplay {
      width: 90%;
      max-width: 450px;
      padding: 20px;
      font-size: 28px;
      margin: 20px auto;
      background: #ffffff;
      border: 4px dashed #2196f3;
      border-radius: 20px;
      min-height: 30px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: opacity 0.3s ease;
    }

    #wordDisplay.fade {
      opacity: 0;
    }

    button {
      padding: 20px 30px;
      font-size: 26px;
      margin: 15px auto;
      display: block;
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      touch-action: manipulation;
      transition: transform 0.2s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    button:hover:not(:disabled) {
      transform: scale(1.1);
    }

    button:active:not(:disabled) {
      transform: scale(0.95);
    }

    select {
      width: 90%;
      max-width: 300px;
      padding: 15px;
      font-size: 24px;
      margin: 15px auto;
      display: block;
      background: #ffeb3b;
      color: #d81b60;
      border: 3px solid #f06292;
      border-radius: 20px;
      cursor: pointer;
    }

    button:disabled,
    select:disabled {
      /* General disabled style removed */
    }

    #pronounce:disabled {
      background-color: #cccccc !important;
      cursor: not-allowed;
      box-shadow: none;
      opacity: 0.6;
    }

    #pronounce {
      width: 90%;
      max-width: 350px;
      background: #4caf50;
    }

    #checkAnswer {
      width: 90%;
      max-width: 350px;
      background: #ff9800;
    }

    #showAnswer {
      width: 90%;
      max-width: 350px;
      background: #2196f3;
      display: none;
    }

    #showAnswer:disabled {
      background-color: #cccccc !important;
      cursor: not-allowed;
      box-shadow: none;
      opacity: 0.6;
    }

    #keyboard {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 700px;
      margin: 20px auto;
    }

    .key {
      width: 60px;
      height: 60px;
      margin: 8px;
      font-size: 24px;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 3px solid #1976d2;
      border-radius: 15px;
      cursor: pointer;
      touch-action: manipulation;
      transition: transform 0.1s;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
    }

    .key:hover:not(:disabled) {
      transform: scale(1.1);
    }

    .key:active:not(:disabled) {
      transform: scale(0.9);
    }

    .key:disabled {
      background: #cccccc;
      border-color: #aaaaaa;
      box-shadow: none;
      opacity: 0.6;
      cursor: not-allowed;
    }

    #backspace {
      width: 90px;
      background: linear-gradient(135deg, #f44336, #ef5350);
      border-color: #d32f2f;
    }

    #clear {
      width: 90px;
      background: linear-gradient(135deg, #9c27b0, #ab47bc);
      border-color: #7b1fa2;
    }

    #feedback {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      padding: 40px;
      font-size: 36px;
      font-weight: bold;
      color: white;
      border-radius: 30px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      animation: popIn 0.5s ease-out;
    }

    #feedback.wrong {
      background: #f44336;
      border: 5px solid #c62828;
    }

    #celebration,
    #level-complete {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      pointer-events: none;
    }

    .celebration-text,
    .level-complete-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #ffffff;
      text-shadow: 2px 2px 4px #000000;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      text-align: center;
    }

    .level-complete-text span:first-child {
      font-size: 72px;
      color: #ffeb3b;
      animation: pulse 1s infinite;
    }

    .level-complete-text span:last-child {
      font-size: 36px;
      color: #ffffff;
    }

    .star {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #ffeb3b;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: spin 1.5s linear infinite;
    }

    .balloon {
      position: absolute;
      width: 30px;
      height: 40px;
      background: #f06292;
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      animation: float 2s ease-in-out infinite;
    }

    .firework {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #2196f3;
      border-radius: 50%;
      animation: explode 1s ease-out forwards;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff9800;
      transform: rotate(45deg);
      animation: fall 2s linear forwards;
    }

    #mascot {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 100px;
      height: 100px;
      background: url('https://img.icons8.com/ios-filled/100/000000/bee.png') no-repeat center;
      background-size: contain;
      transition: transform 0.5s;
      cursor: pointer;
      z-index: 10;
    }

    #mascot.happy {
      transform: scale(1.2) rotate(10deg);
    }

    #mascot.sad {
      transform: scale(0.9) rotate(-10deg);
    }

    #confirmPopup,
    #resetConfirmPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 235, 59, 0.9);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      text-align: center;
      max-width: 80%;
      animation: popIn 0.5s ease-out;
    }

    #confirmPopup p,
    #resetConfirmPopup p {
      font-size: 28px;
      color: #d81b60;
      margin: 0 0 20px 0;
    }

    #confirmPopup button,
    #resetConfirmPopup button {
      width: 140px;
      padding: 10px;
      font-size: 18px;
      margin: 5px;
      display: inline-block;
    }

    #confirmYes { background: #4caf50; }
    #confirmNo { background: #f44336; }
    #resetAll { background: #f44336; }
    #resetLevel { background: #ff9800; }
    #addStar { background: #4caf50; }
    #removeStar { background: #2196f3; }
    #resetCancel { background: #9e9e9e; }

    #review-mode {
      max-width: 700px;
      margin: 20px auto;
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    #review-mode > div {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
    }

    #passwordPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 235, 59, 0.9);
      padding: 15px;
      border-radius: 20px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      text-align: center;
      max-width: 360px;
      width: 90%;
      animation: popIn 0.5s ease-out;
    }

    #passwordPopup p {
      font-size: 20px;
      color: #d81b60;
      margin: 0 0 6px 0;
    }

    #passwordPopup button {
      width: 80px;
      padding: 6px;
      font-size: 14px;
      margin: 5px;
      display: inline-block;
    }

    #passwordSubmit { background: #4caf50; }
    #passwordCancel { background: #f44336; }

    /* --- Updated Keypad Styles --- */
    #keypad {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      gap: 5px;
      max-width: 170px;
      margin: 10px auto 10px auto;
      justify-content: center;
    }

    #keypad .keypad-btn {
      width: 50px !important;
      height: 50px !important;
      font-size: 22px;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 2px solid #1976d2;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.1s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      line-height: 50px;
      text-align: center;
      touch-action: manipulation;
    }

    #keypad .keypad-btn:hover {
      transform: scale(1.1);
    }

    #keypad .keypad-btn:active {
      transform: scale(0.9);
    }

    #keypad #keypadClear {
      background: linear-gradient(135deg, #f44336, #ef5350);
      border-color: #d32f2f;
      grid-column: 2 / 3;
    }
    /* --- End of Updated Keypad Styles --- */

    #passwordDisplay {
      font-size: 20px;
      color: #d81b60;
      margin: 5px 0;
      min-height: 20px;
    }

    #passwordFeedback {
      font-size: 12px;
      color: #f44336;
      margin: 5px 0;
      min-height: 14px;
    }

    @keyframes shake {
      0% { transform: translate(-50%, -50%) translateX(0); }
      25% { transform: translate(-50%, -50%) translateX(-5px); }
      50% { transform: translate(-50%, -50%) translateX(5px); }
      75% { transform: translate(-50%, -50%) translateX(-5px); }
      100% { transform: translate(-50%, -50%) translateX(0); }
    }

    .shake {
      animation: shake 0.5s ease-in-out;
    }

    @media (max-width: 768px) {
      /* --- Updated Mobile Keypad Styles --- */
      #keypad {
        grid-template-columns: repeat(3, 45px);
        gap: 4px;
        max-width: 145px;
      }

      #keypad .keypad-btn {
        width: 45px !important;
        height: 45px !important;
        font-size: 20px;
        border-radius: 8px;
        line-height: 45px;
      }
      /* --- End of Updated Mobile Keypad Styles --- */

      /* Other mobile styles below... */
      h1 {
        font-size: 36px;
        margin-top: 20px;
      }

      #part,
      #definition,
      #wordIndex {
        font-size: 20px;
        padding: 8px;
      }

      #wordDisplay {
        font-size: 24px;
        padding: 15px;
      }

      button,
      select {
        font-size: 22px;
        padding: 15px 25px;
      }

      #passwordPopup button {
        width: 70px;
        font-size: 12px;
        padding: 5px;
      }

      .key {
        width: 50px;
        height: 50px;
        font-size: 20px;
        margin: 5px;
      }

      #backspace,
      #clear {
        width: 70px;
      }

      #feedback {
        font-size: 28px;
        padding: 30px;
      }

      .celebration-text {
        font-size: 36px;
      }

      .level-complete-text span:first-child {
        font-size: 48px;
      }

      .level-complete-text span:last-child {
        font-size: 24px;
      }

      .star {
        width: 30px;
        height: 30px;
      }

      .balloon {
        width: 20px;
        height: 30px;
      }

      .firework,
      .confetti {
        width: 8px;
        height: 8px;
      }

      #mascot {
        width: 60px;
        height: 60px;
        bottom: 10px;
        right: 10px;
      }

      .bee {
        width: 30px;
        height: 30px;
      }

      #progress-text {
        font-size: 18px;
      }

      #header {
        padding: 10px;
      }

      #pronounce-toggle button {
        width: 90px;
        padding: 6px 10px;
        font-size: 12px;
      }

      #wordListButton,
      #resetButton {
        width: 80px;
        padding: 6px 10px;
        font-size: 12px;
      }

      #confirmPopup p,
      #resetConfirmPopup p {
        font-size: 24px;
      }

      #confirmPopup button,
      #resetConfirmPopup button {
        width: 100px;
        font-size: 18px;
        padding: 12px;
      }

      .word-button {
        font-size: 22px;
        padding: 8px 15px;
      }

      .redo-button {
        font-size: 20px;
        padding: 12px 25px;
      }

      #passwordPopup {
        max-width: 320px;
        padding: 10px;
      }

      #passwordPopup p {
        font-size: 18px;
      }

      #passwordDisplay {
        font-size: 18px;
        margin: 4px 0;
      }

      #passwordFeedback {
        font-size: 10px;
        margin: 4px 0;
      }
    }
    /* --- End of media query --- */

    .word-button {
      padding: 10px 20px;
      font-size: 28px;
      font-weight: bold;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 4px solid #1976d2;
      border-radius: 15px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    .word-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    .word-button:active {
      transform: scale(0.95);
    }

    .redo-button {
      padding: 15px 30px;
      font-size: 26px;
      background: linear-gradient(135deg, #4caf50, #66bb6a);
      color: white;
      border: 4px solid #388e3c;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      margin-top: 20px;
    }

    .redo-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
    }

    .redo-button:active {
      transform: scale(0.95);
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-15px); }
      60% { transform: translateY(-10px); }
    }

    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      80% { transform: translate(-50%, -50%) scale(1.15); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    @keyframes spin {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.2); }
      100% { transform: rotate(360deg) scale(1); }
    }

    @keyframes float {
      0% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
      100% { transform: translateY(0); }
    }

    @keyframes explode {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(10); opacity: 0; }
    }

    @keyframes fall {
      0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
  </style>
</head>
<body>
  <div id="header">
    <div id="pronounce-toggle">
      <button id="fullPronounce" onclick="togglePronounce()">Full Pronunciation: On</button>
    </div>
    <button id="wordListButton" onclick="showConfirmPopup()">Word List</button>
    <button id="resetButton" onclick="showResetConfirmPopup()">Reset Progress</button>
  </div>

  <h1>Spelling Bee Adventure</h1>

  <div id="mainContent">
    <select id="levelSelect" onchange="changeLevel()">
      <option value="0">Level 1-a</option>
      <option value="1">Level 1-b</option>
      <option value="2">Level 1-c</option>
      <option value="3">Level 1-d</option>
      <option value="4">Level 1-e</option>
      <option value="5">Level 2-a</option>
      <option value="6">Level 2-b</option>
      <option value="7">Level 2-c</option>
      <option value="8">Level 2-d</option>
      <option value="9">Level 2-e</option>
      <option value="10">Level 3-a</option>
      <option value="11">Level 3-b</option>
      <option value="12">Level 3-c</option>
      <option value="13">Level 3-d</option>
      <option value="14">Level 3-e</option>
      <option value="15">Level 4</option>
      <option value="16">Level 5</option>
      <option value="17">Level 6</option>
      <option value="18">Level 7</option>
      <option value="19">Level 8</option>
      <option value="20">Level 9</option>
    </select>

    <div id="progress"></div>

    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>

    <div id="progress-text">Words Completed: 0/10 <div class="bee"></div></div>

    <div id="part"></div>
    <div id="definition"></div>
    <div id="wordIndex"></div>

    <button id="pronounce" onclick="pronounceWord()">Pronounce</button>

    <div id="wordDisplay"></div>

    <div id="keyboard"></div>

    <button id="checkAnswer" onclick="checkSpelling()">Check Answer</button>
    <button id="showAnswer" onclick="showAnswer()">Show Answer</button>
  </div>

  <div id="feedback" onclick="hideFeedback()"></div>

  <div id="celebration">
    <div class="celebration-text">🎉 Great Job! 🎉</div>
  </div>

  <div id="level-complete">
    <div class="level-complete-text">
      <span>🎉 Level Complete! 🎉</span>
      <span></span>
    </div>
  </div>

  <div id="mascot"></div>

  <div id="confirmPopup">
    <p>Want to peek at the word list?</p>
    <button id="confirmYes" onclick="goToWordList()">Yes</button>
    <button id="confirmNo" onclick="hideConfirmPopup()">No</button>
  </div>

  <div id="passwordPopup">
    <p>Enter Password to Reset:</p>
    <div id="passwordDisplay"></div>
    <div id="passwordFeedback"></div>
    <div id="keypad">
      <button class="keypad-btn" onclick="appendPasswordDigit('1')">1</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('2')">2</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('3')">3</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('4')">4</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('5')">5</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('6')">6</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('7')">7</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('8')">8</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('9')">9</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('0')">0</button>
      <button id="keypadClear" class="keypad-btn" onclick="clearPassword()">Clear</button>
    </div>
    <button id="passwordSubmit" onclick="checkPassword()">Submit</button>
    <button id="passwordCancel" onclick="hidePasswordPopup()">Cancel</button>
  </div>

  <div id="resetConfirmPopup">
    <p>Reset Options:</p>
    <button id="resetAll" onclick="resetAllProgress()">Reset All Progress</button>
    <button id="resetLevel" onclick="resetCurrentLevel()">Reset Current Level</button>
    <button id="addStar" onclick="addStarToLevel()">Add Star</button>
    <button id="removeStar" onclick="removeStarFromLevel()">Remove Star</button>
    <button id="resetCancel" onclick="hideResetConfirmPopup()">Cancel</button>
  </div>

  <div id="review-mode"></div>

  <script src="https://geniusjazz.github.io/spelling-bee/words_full.js"></script>

  <script>
    'use strict'; // Enable strict mode

    let currentLevel = 0;
    let levelStates = {};
    let levelCompletions = {};
    let lastPronouncedIndex = -1;
    let isSpeaking = false;
    let tapCount = 0;
    let tapTimeout;
    let fullPronounceEnabled = true;
    let currentPassword = "";

    // --- UTILITY FUNCTIONS ---
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function playSound(type) {
      const audio = new Audio();
      if (type === 'correct') audio.src = 'https://www.soundjay.com/buttons/sounds/button-3.mp3';
      else if (type === 'wrong') audio.src = 'https://www.soundjay.com/buttons/sounds/beep-03.mp3';
      else if (type === 'levelComplete') audio.src = 'https://www.soundjay.com/human/sounds/cheering-01.mp3';
      audio.volume = 0.7;
      audio.play().catch((err) => console.warn(`Sound ${type} failed to play:`, err));
    }

    // --- STATE MANAGEMENT ---
    function saveGameState() {
      if (!levelStates[currentLevel]) {
        /*console.warn("Save state: Uninitialized level:", currentLevel);*/
        return;
      }
      const state = levelStates[currentLevel];
      // Ensure all expected properties exist before saving
      const stateToSave = {
        failCount: state.failCount ?? 0,
        wordsCompleted: state.wordsCompleted ?? 0,
        wordIndices: state.wordIndices ?? [],
        indexPointer: state.indexPointer ?? 0,
        isReviewMode: state.isReviewMode ?? false,
        missedWords: state.missedWords ?? [],
      };
      try {
        localStorage.setItem('currentLevel', currentLevel);
        localStorage.setItem(`levelState_${currentLevel}`, JSON.stringify(stateToSave));
        localStorage.setItem('levelCompletions', JSON.stringify(levelCompletions));
        localStorage.setItem('fullPronounceEnabled', fullPronounceEnabled);
      } catch (e) {
        console.error("Error saving game state:", e);
      }
    }

    function loadGameState() {
      console.log("Loading game state...");
      try {
        currentLevel = parseInt(localStorage.getItem('currentLevel')) || 0;
        levelCompletions = JSON.parse(localStorage.getItem('levelCompletions')) || {};
        fullPronounceEnabled = localStorage.getItem('fullPronounceEnabled') !== 'false';
        levelStates = {};
        for (let i = 0; i < 21; i++) { // Assuming max level index 20
          const stored = localStorage.getItem(`levelState_${i}`);
          if (stored) {
            try {
              levelStates[i] = JSON.parse(stored);
              // Add back transient properties needed at runtime
              levelStates[i].currentIndex = levelStates[i].wordIndices ? levelStates[i].wordIndices[levelStates[i].indexPointer] : 0;
              levelStates[i].currentWord = "";
            } catch (pErr) {
              console.error(`Parse error level ${i}:`, pErr);
              localStorage.removeItem(`levelState_${i}`); // Remove corrupted data
            }
          }
        }
        document.getElementById("levelSelect").value = currentLevel;
        updatePronounceButton();
        updateLevelSelect();
        if (!levelStates[currentLevel]) {
          console.log(`Init level ${currentLevel} from load.`);
          initializeLevelState(currentLevel);
        } else {
          console.log("Loaded state for current level:", currentLevel);
        }
      } catch (e) {
        console.error("Error loading game state:", e);
        currentLevel = 0;
        levelStates = {};
        levelCompletions = {};
        fullPronounceEnabled = true;
        initializeLevelState(currentLevel);
        updateLevelSelect();
      }
    }

    function initializeLevelState(level) {
      console.log(`Initializing level ${level}...`);
      const isR = levelStates[level]?.isReviewMode || false;
      const miss = levelStates[level]?.missedWords || [];
      levelStates[level] = {
        failCount: 0,
        wordsCompleted: 0,
        wordIndices: [],
        indexPointer: 0,
        isReviewMode: isR,
        missedWords: isR ? miss : [],
        currentIndex: 0,
        currentWord: ""
      };
      initializeWordIndices(level); // This now saves state
    }

    function initializeWordIndices(level) {
      if (!levelStates[level]) {
        console.error("InitIndices: No state:", level);
        return;
      }
      const state = levelStates[level];
      const lWords = getLevelWords(); // Get word objects for the level
      let srcArr;

      if (state.isReviewMode) {
        srcArr = state.missedWords;
        if (!srcArr || srcArr.length === 0) {
          console.warn(`Review mode level ${level} no missed words.`);
          state.isReviewMode = false; // Ensure review mode is off
          saveGameState(); // Save state change before completing
          endReviewMode(true); // Complete the level (forced)
          return; // Stop initialization
        }
        state.wordIndices = shuffle(Array.from({ length: srcArr.length }, (_, i) => i));
        console.log(`Init indices level ${level} (review ${state.wordIndices.length})`);
      } else {
        srcArr = lWords;
        if (!srcArr || srcArr.length === 0) {
          console.error(`No words level ${level} normal.`);
          // Handle error: Maybe alert user or disable game functions?
          alert(`Could not load words for level ${level + 1}. Please select another level.`);
          return;
        }
        state.wordIndices = shuffle(Array.from({ length: srcArr.length }, (_, i) => i));
        console.log(`Init indices level ${level} (normal ${state.wordIndices.length})`);
      }
      // Reset state for the new list
      state.indexPointer = 0;
      state.currentWord = "";
      state.failCount = 0;
      lastPronouncedIndex = -1; // Reset pronunciation tracking
      updateProgress(); // Update UI
      saveGameState(); // Save the newly initialized/reset state
    }


    // --- UI UPDATES ---
    function updatePronounceButton() {
      const btn = document.getElementById("fullPronounce");
      btn.innerText = `Full Pronunciation: ${fullPronounceEnabled ? 'On' : 'Off'}`;
      btn.className = fullPronounceEnabled ? '' : 'off';
    }

    function updateLevelSelect() {
      const sel = document.getElementById("levelSelect");
      const base = ["Level 1-a", "Level 1-b", "Level 1-c", "Level 1-d", "Level 1-e", "Level 2-a", "Level 2-b", "Level 2-c", "Level 2-d", "Level 2-e", "Level 3-a", "Level 3-b", "Level 3-c", "Level 3-d", "Level 3-e", "Level 4", "Level 5", "Level 6", "Level 7", "Level 8", "Level 9"];
      for (let i = 0; i < sel.options.length; i++) {
        if (i >= base.length) break;
        const lvl = parseInt(sel.options[i].value);
        const txt = base[i];
        const comp = levelCompletions[lvl] || 0;
        const star = comp % 5;
        const troph = Math.floor(comp / 5);
        let suf = '';
        if (troph > 0) suf += ' 🏆'.repeat(troph);
        if (star > 0) suf += ' ⭐'.repeat(star);
        sel.options[i].text = txt + suf;
      }
    }

    function updateDisplay() {
      const wd = document.getElementById("wordDisplay");
      if (!levelStates[currentLevel]) return;
      wd.innerText = levelStates[currentLevel]?.currentWord || "";
    }

    function updateProgress() {
      if (!levelStates[currentLevel]) return;
      const st = levelStates[currentLevel];
      const pb = document.getElementById("progress-bar");
      const pt = document.getElementById("progress-text");
      let tot = 0;
      if (st.isReviewMode) {
        tot = st.missedWords?.length || 0;
      } else {
        tot = (currentLevel < 15 ? 10 : 50);
      }
      pb.style.width = tot > 0 ? `${(st.wordsCompleted / tot) * 100}%` : '0%';
      pt.innerHTML = `Words Completed: ${st.wordsCompleted}/${tot} <div class="bee"></div>`;
    }

    function showFeedback(msg, isCorrect) {
      const fb = document.getElementById("feedback");
      const ms = document.getElementById("mascot");
      fb.innerText = msg;
      fb.className = isCorrect ? "" : "wrong";
      fb.style.display = msg ? "block" : "none";
      ms.className = isCorrect ? "happy" : "sad";
      if (!isCorrect && msg) {
        setTimeout(() => {
          // Check if feedback is still showing the same message before hiding
          if (fb.innerText === msg && fb.style.display === 'block') {
            fb.style.display = "none";
            ms.className = "";
          }
        }, 1500);
      } else if (isCorrect) {
        ms.className = "happy"; // Show happy mascot immediately
      }
    }

    function hideFeedback() {
      document.getElementById("feedback").style.display = "none";
      document.getElementById("mascot").className = "";
    }

    // --- GAME LOGIC ---
    function getLevelWords() {
      const st = levelStates[currentLevel];
      if (!st) {
        console.error("GetLevelWords: No state:", currentLevel);
        return [];
      }
      if (st.isReviewMode) {
        return st.missedWords || [];
      }
      let start;
      if (currentLevel < 5) start = currentLevel * 10;
      else if (currentLevel < 10) start = 50 + (currentLevel - 5) * 10;
      else if (currentLevel < 15) start = 100 + (currentLevel - 10) * 10;
      else start = 150 + (currentLevel - 15) * 50;
      const cnt = currentLevel < 15 ? 10 : 50;
      if (typeof words === 'undefined' || !Array.isArray(words)) {
        console.error("'words' missing!");
        return [];
      }
      if (start >= words.length) {
        console.warn(`Lvl ${currentLevel} start ${start} out of bounds.`);
        return [];
      }
      // Ensure count doesn't exceed available words
      return words.slice(start, Math.min(start + cnt, words.length));
    }

    function showWord() {
      /*console.log("---- showWord ----");*/ // Reduce console noise
      if (!levelStates[currentLevel]) {
        console.error(`ShowWord: State missing ${currentLevel}. Init.`);
        initializeLevelState(currentLevel);
        if (!levelStates[currentLevel]) {
          alert("Failed init state.");
          return;
        }
      }
      const st = levelStates[currentLevel];
      const lWords = getLevelWords();

      if (!lWords || lWords.length === 0) {
        console.error("No words for level/mode:", currentLevel, st.isReviewMode);
        if (st.isReviewMode) {
          console.log("No review words, end review.");
          endReviewMode(true);
        } else {
          alert(`Error: No words found for Level.`);
        }
        return;
      }
      if (!st.wordIndices || st.wordIndices.length === 0 || st.indexPointer >= st.wordIndices.length) {
        console.warn("Idx issue showWord. Reinit indices:", currentLevel);
        initializeWordIndices(currentLevel);
        if (!st.wordIndices || st.wordIndices.length === 0) {
          console.error("Failed reinit indices.");
          return;
        }
      }

      const wordIdxSrc = st.wordIndices[st.indexPointer];
      // Ensure index is valid before accessing word data
      if (wordIdxSrc < 0 || wordIdxSrc >= lWords.length) {
        console.error("Invalid word index derived:", {
          pointer: st.indexPointer,
          derivedIndex: wordIdxSrc,
          listLength: lWords.length
        });
        initializeWordIndices(currentLevel);
        return;
      }
      const w = lWords[wordIdxSrc];

      if (!w || !w.word || !w.part || !w.definition || typeof w.no === 'undefined') {
        console.error("Invalid word data retrieved:", {
          wordIdxSrc,
          w,
          lWordsLen: lWords.length
        });
        alert("Error retrieving word data.");
        return;
      }

      st.currentIndex = wordIdxSrc; // Store the index within the *current* word list (lWords)
      console.log(`Display: Ptr=${st.indexPointer}, Idx=${st.currentIndex}, Word=${w.word}`);
      document.getElementById("part").innerText = "Part of Speech: " + w.part;
      document.getElementById("definition").innerText = "Definition: " + w.definition;
      document.getElementById("wordIndex").innerText = "Word #" + w.no;
      st.currentWord = "";
      updateDisplay();

      const showAnsBtn = document.getElementById("showAnswer");
      showAnsBtn.style.display = st.failCount >= 3 ? "block" : "none";
      showAnsBtn.disabled = st.failCount < 3; // Ensure disabled state matches visibility

      document.getElementById("mainContent").style.display = "block";
      const revDiv = document.getElementById("review-mode");
      if (revDiv) revDiv.style.display = "none";
      document.getElementById("mascot").className = "";
      updateProgress();

      // Enable controls (pronounce state handled separately)
      document.getElementById("checkAnswer").disabled = false;
      document.getElementById("levelSelect").disabled = false;
      document.querySelectorAll('.key').forEach(key => key.disabled = false);
      document.getElementById("pronounce").disabled = isSpeaking; // Ensure pronounce reflects current speaking state
    }

    // --- UPDATED changeLevel Function ---
    function changeLevel() {
      if (isSpeaking) {
        console.log("Level changed - cancelling speech.");
        speechSynthesis.cancel();
        isSpeaking = false;
      }
      const newLvl = parseInt(document.getElementById("levelSelect").value);
      console.log("Changing level to:", newLvl);
      currentLevel = newLvl;
      localStorage.setItem('currentLevel', currentLevel);
      if (!levelStates[currentLevel]) {
        initializeLevelState(currentLevel);
      } else {
        levelStates[currentLevel].currentWord = ""; // Clear input on level switch
        console.log("Loaded existing state level", newLvl);
      }
      showWord(); // Display word for the new level
    }

    // --- UPDATED checkSpelling Function ---
    function checkSpelling() {
      if (isSpeaking) {
        console.log("Check clicked - cancelling speech.");
        speechSynthesis.cancel();
        isSpeaking = false;
      }
      if (!levelStates[currentLevel]) {
        console.error("Check: No state.");
        return;
      }
      const st = levelStates[currentLevel];
      const lWords = getLevelWords();
      if (st.currentIndex < 0 || !lWords || st.currentIndex >= lWords.length) {
        console.error("Check: Invalid index/data:", st.currentIndex);
        showWord(); // Re-show word if index is bad
        return;
      }

      const correct = lWords[st.currentIndex].word;
      const input = st.currentWord.trim().toLowerCase();
      console.log("Check:", { input, correct });

      if (input === correct) {
        st.wordsCompleted++;
        playSound('correct');
        showFeedback("", true); // Correct, no text needed
        showCelebration(); // This leads to nextWord after animation
        saveGameState();
      } else {
        st.failCount++;
        if (st.failCount === 1 && !st.isReviewMode) {
          if (!st.missedWords) st.missedWords = [];
          // Add word object if not already missed
          if (!st.missedWords.some(mw => mw.no === lWords[st.currentIndex].no)) {
            st.missedWords.push(lWords[st.currentIndex]);
            console.log("Added missed:", lWords[st.currentIndex].word);
          }
        }
        playSound('wrong');
        showFeedback("❌ Oops! Try Again! ❌", false);
        const showAnsBtn = document.getElementById("showAnswer");
        if (st.failCount >= 3) {
          showAnsBtn.style.display = "block";
          showAnsBtn.disabled = false;
        } else {
          showAnsBtn.style.display = "none";
          showAnsBtn.disabled = true;
        }
        st.currentWord = ""; // Clear input field on wrong answer
        updateDisplay();
        saveGameState();
      }
    }

    // --- UPDATED showAnswer Function ---
    function showAnswer() {
      if (isSpeaking) {
        console.log("ShowAns clicked - cancelling speech.");
        speechSynthesis.cancel();
        isSpeaking = false;
      }
      if (!levelStates[currentLevel]) return;
      const st = levelStates[currentLevel];
      const lWords = getLevelWords();
      if (st.currentIndex < 0 || !lWords || st.currentIndex >= lWords.length) {
        console.error("ShowAns: Invalid index/data:", st.currentIndex);
        return;
      }
      const correct = lWords[st.currentIndex].word;
      showFeedback(`Answer: ${correct}`, false); // Show answer as feedback
    }

    function nextWord() {
      // console.log("---- nextWord ----"); // Reduce noise
      if (!levelStates[currentLevel]) {
        console.error("NextWord: No state.");
        return;
      }
      const st = levelStates[currentLevel];
      st.indexPointer++;
      const listLen = st.wordIndices?.length || 0; // Use optional chaining

      // Check completion status
      if (st.indexPointer >= listLen) {
        console.log("Finished list.");
        if (st.isReviewMode) {
          console.log("Ending review.");
          endReviewMode();
        } else if (st.missedWords && st.missedWords.length > 0) {
          console.log("Starting review.");
          showReviewMode();
        } else {
          console.log("No missed, completing.");
          endReviewMode(true); // Force completion if no missed words
        }
        return; // Stop processing as we transition
      }

      // Prepare for next word
      st.failCount = 0;
      isSpeaking = false; // Ensure flag is reset
      speechSynthesis.cancel(); // Cancel any leftover speech
      st.currentWord = "";
      lastPronouncedIndex = -1; // Reset pronunciation tracking
      showWord(); // Display the next word
      saveGameState(); // Save state after successfully moving to next word
    }

    // --- PRONUNCIATION ---
    // --- UPDATED pronounceWord Function ---
    function pronounceWord() {
      if (isSpeaking) {
        console.log("Pronounce clicked - cancelling previous.");
        speechSynthesis.cancel();
        isSpeaking = false; /* Let finally block enable button */
      }
      if (!levelStates[currentLevel]) {
        console.error("Pronounce: No state.");
        return;
      }
      const st = levelStates[currentLevel];
      const lWords = getLevelWords();
      // Check word data validity before proceeding
      if (!lWords || st.currentIndex < 0 || st.currentIndex >= lWords.length || !lWords[st.currentIndex] || !lWords[st.currentIndex].word) {
        console.error("Pronounce: Word data not ready.");
        showFeedback("Word not ready.", false);
        return;
      }
      console.log("Pronounce clicked - starting sequence.");
      isSpeaking = true; // Set flag *before* calling async func
      disableButtons(); // Disable pronounce button ONLY
      pronounceSequence(); // Call the async sequence handler
    }

    // --- ASYNC PRONUNCIATION SEQUENCE HANDLER (with refined catch) ---
    const pronounceSequence = async () => {
      const st = levelStates[currentLevel];
      // Re-check state validity at the start of the async function
      if (!st || !st.wordIndices || st.indexPointer >= st.wordIndices.length) {
        console.error("Seq: Invalid state.");
        isSpeaking = false;
        enableButtons();
        return;
      }
      const lWords = getLevelWords();
      if (st.currentIndex < 0 || st.currentIndex >= lWords.length) {
        console.error("Seq: Invalid index.");
        isSpeaking = false;
        enableButtons();
        return;
      }
      const w = lWords[st.currentIndex];
      if (!w || !w.word) {
        console.error("Seq: Invalid word data.");
        isSpeaking = false;
        enableButtons();
        return;
      }

      const word = w.word.toLowerCase();
      const runFull = fullPronounceEnabled && st.currentIndex !== lastPronouncedIndex;

      try {
        // Attempt 1: Howjsay or TTS Fallback
        try {
          await playHowjsayAudio();
        } catch (err) {
          if (err && (err.message === 'Interrupted' || err.message === 'Cancelled')) {
            console.log("Seq: Howjsay cancelled.");
            isSpeaking = false;
            return;
          } // Stop if cancelled
          else {
            console.warn("Seq: Howjsay failed, using TTS1:", err);
            await speakText(word);
          } // Use fallback
        }
        // Check cancellation after attempt 1 finishes/fails
        if (!isSpeaking) { /*console.log("Seq: Cancelled after attempt 1.");*/
          return;
        }

        await new Promise(r => setTimeout(r, 250)); // Pause
        if (!isSpeaking) { /*console.log("Seq: Cancelled during pause 1.");*/
          return;
        }

        // Attempt 2: Always TTS
        await speakText(word);
        if (!isSpeaking) { /*console.log("Seq: Cancelled after attempt 2.");*/
          return;
        }

        // Optional Full Sequence Details
        if (runFull) {
          await new Promise(r => setTimeout(r, 800));
          if (!isSpeaking) { /*console.log("Seq: Cancelled pause 2.");*/
            return;
          }
          console.log("Seq: Running full details...");
          if (w.part) await speakText(`Part of speech: ${w.part}`);
          if (!isSpeaking) { /*console.log("Seq: Cancelled after part.");*/
            return;
          }
          if (w.definition) await speakText(`Definition: ${w.definition}`);
          if (!isSpeaking) { /*console.log("Seq: Cancelled after def.");*/
            return;
          }
          await new Promise(r => setTimeout(r, 500));
          if (!isSpeaking) { /*console.log("Seq: Cancelled pause 3.");*/
            return;
          }
          await speakText("Please spell");
          if (!isSpeaking) { /*console.log("Seq: Cancelled after prompt.");*/
            return;
          }
          await new Promise(r => setTimeout(r, 500));
          if (!isSpeaking) { /*console.log("Seq: Cancelled pause 4.");*/
            return;
          }
          await speakText(word); // Final repetition
          if (!isSpeaking) { /*console.log("Seq: Cancelled after final word.");*/
            return;
          }
          lastPronouncedIndex = st.currentIndex; // Update only if full sequence completes
          console.log("Seq: Full sequence complete.");
        }

      } catch (err) {
        // Catch errors from speakText or other await calls
        if (err && (err.message === 'Interrupted' || err.message === 'Cancelled')) {
          console.log("Seq: Intentionally interrupted."); // Log quietly
        } else {
          console.error("Seq: Unexpected error during sequence:", err); // Log other errors
        }
      } finally {
        // This always runs, ensuring state is cleaned up
        if (isSpeaking) { // If flag is still true, it means sequence finished normally or errored unexpectedly
          isSpeaking = false;
        }
        // Always ensure the pronounce button is enabled after the sequence attempt finishes or is cancelled
        enableButtons();
      }
    };
    // --- End of pronounceSequence ---

    // --- Helper: Speak Text (with refined error handling) ---
    const speakText = (text) => {
      return new Promise((resolve, reject) => {
        if (!text || typeof text !== 'string' || text.trim() === "") {
          console.warn("speakText invalid text.");
          return resolve();
        }
        // Check if cancelled *before* starting utterance
        if (!isSpeaking) { /*console.log("speakText cancelled before start.");*/
          return reject(new Error("Cancelled"));
        }

        const utt = new SpeechSynthesisUtterance(text);
        utt.lang = "en-US";
        utt.rate = 0.7;
        utt.pitch = 0.7;
        let ended = false;
        let timer = null;
        const endFn = (evt = {}) => {
          clearTimeout(timer);
          if (ended) return;
          ended = true;
          resolve();
        };
        utt.onend = endFn;
        timer = setTimeout(() => {
          if (!ended) {
            console.warn(`TTS Timeout: "${text}"`);
            endFn({ type: 'timeout' });
          }
        }, text.length * 150 + 1500); // Timeout logic

        utt.onerror = (evt) => {
          clearTimeout(timer);
          if (evt.error === 'interrupted') {
            // console.log(`TTS Interrupted: "${text}"`); // Quiet log
            reject(new Error('Interrupted'));
          } else {
            console.error(`TTS Error: "${text}"`, evt.error);
            reject(evt.error);
          }
        };
        try {
          // Check again just before speaking
          if (!isSpeaking) {
            clearTimeout(timer); /*console.log("speakText cancelled just before speak call.");*/
            reject(new Error("Cancelled"));
            return;
          }
          speechSynthesis.speak(utt);
        } catch (e) {
          clearTimeout(timer);
          console.error("Speak call error:", e);
          reject(e);
        }
      });
    };

    // --- Helper: Play Howjsay Audio ---
    const playHowjsayAudio = () => {
      if (!levelStates[currentLevel] || !levelStates[currentLevel].wordIndices) {
        return Promise.reject(new Error("HJS: State not ready."));
      }
      const st = levelStates[currentLevel];
      const lWords = getLevelWords();
      if (st.currentIndex < 0 || st.currentIndex >= lWords.length) {
        return Promise.reject(new Error("HJS: Invalid index."));
      }
      const w = lWords[st.currentIndex];
      if (!w || !w.word) {
        return Promise.reject(new Error("HJS: Invalid word data."));
      }
      const wordAud = w.word.toLowerCase().replace(/[^a-z\-']/g, ''); // Keep letters, hyphen, apostrophe
      if (!wordAud) {
        return Promise.reject(new Error("HJS: Invalid word after sanitize."));
      }

      const aud = new Audio(`https://howjsay.com/mp3/${wordAud}.mp3`);
      aud.volume = 0.7;
      let timer = null;
      let res = false;
      let rej = false;

      const clean = () => {
        if (timer) clearTimeout(timer);
        aud.oncanplaythrough = null;
        aud.onerror = null;
        aud.onended = null;
        aud.src = "";
        try {
          aud.load();
        } catch (e) {}
      }; // Stop loading/release resource

      return new Promise((resolve, reject) => {
        // Check if cancelled before starting
        if (!isSpeaking) { /*console.log("HJS cancelled before start.");*/
          return reject(new Error("Cancelled"));
        }

        timer = setTimeout(() => {
          if (res || rej) return;
          console.error(`HJS Timeout: "${wordAud}"`);
          rej = true;
          clean();
          reject(new Error("Audio load timeout"));
        }, 3500); // Timeout

        aud.oncanplaythrough = () => {
          if (res || rej) return; /*console.log(`HJS CanPlay: "${wordAud}"`);*/
          aud.play().catch(err => {
            if (res || rej) return;
            console.error(`HJS Play Error: "${wordAud}"`, err);
            rej = true;
            clean();
            reject(err);
          });
        };
        aud.onerror = (e) => {
          if (res || rej) return;
          console.error(`HJS OnError: "${wordAud}"`, aud.error);
          rej = true;
          clean();
          reject(new Error(`Howjsay audio onerror`));
        };
        aud.onended = () => {
          if (res || rej) return; /*console.log(`HJS Finished: "${wordAud}"`);*/
          res = true;
          clean();
          resolve();
        }; // Resolve on successful end

        aud.load(); // Start loading
      });
    };
    // --- End of pronunciation helpers ---


    // --- UPDATED disableButtons Function ---
    function disableButtons() {
      document.getElementById("pronounce").disabled = true;
      // Other buttons remain enabled
    }

    // --- UPDATED enableButtons Function ---
    function enableButtons() {
      // Only needs to enable the pronounce button
      document.getElementById("pronounce").disabled = false;
    }

    // --- LEVEL/REVIEW MODE MANAGEMENT ---
    function endReviewMode(forceComplete = false) {
      if (!levelStates[currentLevel]) return;
      console.log("EndReview/CompleteLevel.");
      levelStates[currentLevel].isReviewMode = false;
      if (!forceComplete || (levelStates[currentLevel].missedWords && levelStates[currentLevel].missedWords.length === 0)) {
        levelCompletions[currentLevel] = (levelCompletions[currentLevel] || 0) + 1;
      }
      saveGameState();
      updateLevelSelect();
      showLevelComplete();
    }

    function showReviewMode() {
      if (!levelStates[currentLevel] || !levelStates[currentLevel].missedWords || levelStates[currentLevel].missedWords.length === 0) {
        console.log("No missed words, completing.");
        endReviewMode(true);
        return;
      }
      const st = levelStates[currentLevel];
      console.log("ShowReview screen.");
      document.getElementById("mainContent").style.display = "none";
      const revDiv = document.getElementById("review-mode");
      if (!revDiv) {
        console.error("Review div missing!");
        return;
      }
      revDiv.innerHTML = '';
      revDiv.style.display = 'flex';
      const listDiv = document.createElement("div");
      st.missedWords.forEach(w => {
        const btn = document.createElement("button");
        btn.className = "word-button";
        btn.innerText = w.word;
        listDiv.appendChild(btn);
      });
      revDiv.appendChild(listDiv);
      const redo = document.createElement("button");
      redo.className = "redo-button";
      redo.innerText = `Redo ${st.missedWords.length} Missed Word(s)`;
      redo.onclick = redoMissedWords;
      revDiv.appendChild(redo);
    }

    function redoMissedWords() {
      console.log("Redo clicked!");
      const revDiv = document.getElementById("review-mode");
      if (revDiv) revDiv.style.display = 'none';
      document.getElementById("mainContent").style.display = "block";
      if (!levelStates[currentLevel] || !levelStates[currentLevel].missedWords || levelStates[currentLevel].missedWords.length === 0) {
        console.warn("Redo no missed words.");
        if (levelStates[currentLevel]) levelStates[currentLevel].isReviewMode = false;
        showWord();
        return;
      }
      const st = levelStates[currentLevel];
      st.isReviewMode = true;
      st.wordsCompleted = 0;
      st.failCount = 0;
      isSpeaking = false;
      speechSynthesis.cancel();
      st.currentWord = "";
      initializeWordIndices(currentLevel);
      if (st.wordIndices && st.wordIndices.length > 0) {
        showWord();
        saveGameState();
      } else {
        console.log("Review init no indices. Completing.");
        endReviewMode(true);
      }
    }

    // --- CELEBRATION & COMPLETION ANIMATIONS ---
    function showCelebration() {
      const cel = document.getElementById("celebration");
      document.getElementById("mainContent").style.display = "none";
      cel.style.display = "block";
      cel.innerHTML = '<div class="celebration-text">🎉 Great Job! 🎉</div>';
      const fxT = [0, 1, 2, 3];
      const fxU = [];
      while (fxU.length === 0) {
        if (Math.random() > 0.6) fxU.push(0);
        if (Math.random() > 0.6) fxU.push(1);
        if (Math.random() > 0.6) fxU.push(2);
        if (Math.random() > 0.6) fxU.push(3);
      }
      fxU.forEach(fxTyp => {
        const cnt = fxTyp === 0 ? 10 : fxTyp === 1 ? 8 : fxTyp === 2 ? 15 : 20;
        for (let i = 0; i < cnt; i++) {
          const el = document.createElement("div");
          el.style.left = `${Math.random() * 100}%`;
          el.style.top = `${Math.random() * 100}%`;
          el.style.animationDelay = `${Math.random() * 0.5}s`;
          const clr = `hsl(${Math.random() * 360}, 90%, 70%)`;
          if (fxTyp === 0) el.className = "star";
          else if (fxTyp === 1) el.className = "balloon";
          else if (fxTyp === 2) el.className = "firework";
          else el.className = "confetti";
          el.style.background = clr;
          cel.appendChild(el);
        }
      });
      setTimeout(hideCelebration, 2000);
    }

    function hideCelebration() {
      const cel = document.getElementById("celebration");
      cel.style.display = "none";
      document.getElementById("mainContent").style.display = "block";
      cel.innerHTML = '<div class="celebration-text">🎉 Great Job! 🎉</div>';
      nextWord();
    }

    function showLevelComplete() {
      const lc = document.getElementById("level-complete");
      document.getElementById("mainContent").style.display = "none";
      lc.style.display = "block";
      lc.innerHTML = '<div class="level-complete-text"><span>🎉 Level Complete! 🎉</span><span></span></div>';
      playSound('levelComplete');
      const lctxt = lc.querySelector(".level-complete-text");
      const lcspan = lctxt.children[1];
      const base = ["Level 1-a", "Level 1-b", "Level 1-c", "Level 1-d", "Level 1-e", "Level 2-a", "Level 2-b", "Level 2-c", "Level 2-d", "Level 2-e", "Level 3-a", "Level 3-b", "Level 3-c", "Level 3-d", "Level 3-e", "Level 4", "Level 5", "Level 6", "Level 7", "Level 8", "Level 9"];
      const comp = levelCompletions[currentLevel] || 0;
      const star = comp % 5;
      const troph = Math.floor(comp / 5);
      const nextIdx = (currentLevel + 1) % base.length;
      const nextName = base[nextIdx];
      let msg = `You now have `;
      if (troph > 0) msg += `${troph} 🏆 `;
      if (star > 0) msg += `${star} ⭐`;
      if (troph === 0 && star === 0 && comp === 1) {
        msg = "You earned your first ⭐!";
      } else if (troph === 0 && star === 0) {
        msg = "Level finished!";
      }
      msg += `<br>Next up: ${nextName}`;
      lcspan.innerHTML = msg;
      updateLevelSelect();
      for (let i = 0; i < 30; i++) {
        const el = document.createElement("div");
        el.style.left = `${Math.random() * 100}%`;
        el.style.top = `${Math.random() * 100}%`;
        el.style.animationDelay = `${Math.random() * 1.5}s`;
        const typ = Math.floor(Math.random() * 4);
        const clr = `hsl(${Math.random() * 360}, 90%, 70%)`;
        if (typ === 0) el.className = "star";
        else el.className = "confetti";
        el.style.background = clr;
        lc.appendChild(el);
      }
      setTimeout(hideLevelComplete, 4000);
    }

    function hideLevelComplete() {
      const lc = document.getElementById("level-complete");
      lc.style.display = "none";
      lc.innerHTML = '<div class="level-complete-text"><span>🎉 Level Complete! 🎉</span><span></span></div>';
      delete levelStates[currentLevel];
      localStorage.removeItem(`levelState_${currentLevel}`);
      const numL = document.getElementById("levelSelect").options.length;
      currentLevel = (currentLevel + 1) % numL;
      localStorage.setItem('currentLevel', currentLevel);
      document.getElementById("levelSelect").value = currentLevel;
      initializeLevelState(currentLevel);
      showWord();
    }

    // --- KEYBOARD INPUT ---
    function appendLetter(letter) {
      if (!levelStates[currentLevel]) return;
      levelStates[currentLevel].currentWord += letter;
      updateDisplay();
    }

    function removeLetter() {
      if (!levelStates[currentLevel]) return;
      levelStates[currentLevel].currentWord = levelStates[currentLevel].currentWord.slice(0, -1);
      updateDisplay();
    }

    function clearWord() {
      if (!levelStates[currentLevel]) return;
      levelStates[currentLevel].currentWord = "";
      updateDisplay();
    }

    function setupKeyboard() {
      /*console.log("Setup keyboard...");*/
      const kbd = document.getElementById("keyboard");
      kbd.innerHTML = '';
      const ltrs = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      ltrs.forEach(lt => {
        const btn = document.createElement("button");
        btn.className = "key";
        btn.innerText = lt;
        btn.onclick = () => appendLetter(lt.toLowerCase());
        kbd.appendChild(btn);
      });
      const bs = document.createElement("button");
      bs.id = "backspace";
      bs.className = "key";
      bs.innerText = "Back";
      bs.onclick = removeLetter;
      kbd.appendChild(bs);
      const cl = document.createElement("button");
      cl.id = "clear";
      cl.className = "key";
      cl.innerText = "Clear";
      cl.onclick = clearWord;
      kbd.appendChild(cl);
      /*console.log("Keyboard done.");*/
    }

    // --- POPUP & RESET LOGIC ---
    function showConfirmPopup() {
      document.getElementById("confirmPopup").style.display = "block";
    }

    function hideConfirmPopup() {
      document.getElementById("confirmPopup").style.display = "none";
    }

    function goToWordList() {
      saveGameState();
      window.location.href = 'wordlist.html';
    }

    function showResetConfirmPopup() {
      document.getElementById("passwordPopup").style.display = "block";
      currentPassword = "";
      updatePasswordDisplay();
      document.getElementById("passwordFeedback").innerText = "";
    }

    function hidePasswordPopup() {
      document.getElementById("passwordPopup").style.display = "none";
      currentPassword = "";
      updatePasswordDisplay();
      document.getElementById("passwordFeedback").innerText = "";
    }

    function appendPasswordDigit(digit) {
      if (currentPassword.length < 4) {
        currentPassword += digit;
        updatePasswordDisplay();
        document.getElementById("passwordFeedback").innerText = "";
      }
    }

    function clearPassword() {
      currentPassword = "";
      updatePasswordDisplay();
      document.getElementById("passwordFeedback").innerText = "";
    }

    function updatePasswordDisplay() {
      document.getElementById("passwordDisplay").innerText = "•".repeat(currentPassword.length);
    }

    function checkPassword() {
      if (currentPassword === "0925") {
        hidePasswordPopup();
        document.getElementById("resetConfirmPopup").style.display = "block";
      } else {
        const pop = document.getElementById("passwordPopup");
        const fb = document.getElementById("passwordFeedback");
        fb.innerText = "Wrong Password!";
        pop.classList.add("shake");
        currentPassword = "";
        updatePasswordDisplay();
        setTimeout(() => {
          pop.classList.remove("shake");
        }, 500);
      }
    }

    function hideResetConfirmPopup() {
      document.getElementById("resetConfirmPopup").style.display = "none";
    }

    function resetAllProgress() {
      if (!confirm("Are you absolutely sure you want to reset ALL progress?")) return;
      console.log("Resetting all...");
      currentLevel = 0;
      levelStates = {};
      levelCompletions = {};
      localStorage.clear();
      document.getElementById("levelSelect").value = 0;
      initializeLevelState(0);
      updateLevelSelect();
      showWord();
      hideResetConfirmPopup();
      alert("All progress reset.");
    }

    // --- UPDATED resetCurrentLevel Confirmation ---
    function resetCurrentLevel() {
      if (!confirm("Reset progress for current level?")) {
        return;
      }
      console.log("Resetting current level:", currentLevel);
      initializeLevelState(currentLevel);
      delete levelCompletions[currentLevel];
      saveGameState();
      updateLevelSelect();
      showWord();
      hideResetConfirmPopup();
      alert("Current level progress reset.");
    }

    function addStarToLevel() {
      if (!levelStates[currentLevel]) initializeLevelState(currentLevel);
      levelCompletions[currentLevel] = (levelCompletions[currentLevel] || 0) + 1;
      updateLevelSelect();
      saveGameState();
      hideResetConfirmPopup();
      console.log("Manual star added level", currentLevel);
    }

    function removeStarFromLevel() {
      if (!levelStates[currentLevel] || !levelCompletions[currentLevel] || levelCompletions[currentLevel] === 0) {
        alert("No stars to remove.");
        hideResetConfirmPopup();
        return;
      }
      levelCompletions[currentLevel] = Math.max(0, levelCompletions[currentLevel] - 1);
      if (levelCompletions[currentLevel] === 0) delete levelCompletions[currentLevel];
      updateLevelSelect();
      saveGameState();
      hideResetConfirmPopup();
      console.log("Manual star removed level", currentLevel);
    }

    // --- EVENT LISTENERS & SHORTCUTS ---
    function togglePronounce() {
      fullPronounceEnabled = !fullPronounceEnabled;
      updatePronounceButton();
      saveGameState();
    }

    function setupKeyboardShortcuts() {
      /*console.log("Setup shortcuts...");*/
      document.addEventListener('keydown', (evt) => {
        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT' || document.activeElement.tagName === 'TEXTAREA') return;
        if (evt.ctrlKey && evt.shiftKey && (evt.key === 'Z' || evt.key === 'z')) {
          evt.preventDefault();
          if (isSpeaking) {
            console.log("Shortcut blocked: speaking");
            return;
          }
          if (!levelStates[currentLevel]) {
            console.log("Shortcut blocked: No state");
            return;
          }
          const st = levelStates[currentLevel];
          const lWords = getLevelWords();
          if (!st || !st.wordIndices || st.indexPointer >= st.wordIndices.length) {
            console.log("Shortcut blocked: Invalid state/complete");
            return;
          }
          if (st.currentIndex < 0 || !lWords || st.currentIndex >= lWords.length) {
            console.log("Shortcut blocked: Invalid index/data");
            return;
          }
          const correct = lWords[st.currentIndex]?.word;
          if (!correct) {
            console.log("Shortcut blocked: No word");
            return;
          }
          console.log("Shortcut: Set&Check.");
          st.currentWord = correct;
          updateDisplay();
          setTimeout(checkSpelling, 50);
        }
      });
      /*console.log("Shortcuts done.");*/
    }

    function setupMascotTap() {
      const masc = document.getElementById("mascot");
      masc.addEventListener('touchstart', (evt) => {
        evt.preventDefault();
        handleMascotInteraction();
      });
      masc.addEventListener('click', handleMascotInteraction);
    }

    function handleMascotInteraction() {
      tapCount++;
      clearTimeout(tapTimeout);
      tapTimeout = setTimeout(() => {
        tapCount = 0;
      }, 500);
      if (tapCount === 3) {
        console.log("Mascot tap.");
        tapCount = 0;
        if (isSpeaking) {
          console.log("Mascot blocked: speaking.");
          return;
        }
        if (!levelStates[currentLevel]) {
          console.log("Mascot blocked: No state");
          return;
        }
        const st = levelStates[currentLevel];
        const lWords = getLevelWords();
        if (!st || !st.wordIndices || st.indexPointer >= st.wordIndices.length) {
          console.log("Mascot blocked: Invalid state/complete");
          return;
        }
        if (st.currentIndex < 0 || !lWords || st.currentIndex >= lWords.length) {
          console.log("Mascot blocked: Invalid index/data");
          return;
        }
        const correct = lWords[st.currentIndex]?.word;
        if (!correct) {
          console.log("Mascot blocked: No word");
          return;
        }
        console.log("Mascot: Set&Check.");
        st.currentWord = correct;
        updateDisplay();
        setTimeout(checkSpelling, 50);
      }
    }

    function setupButtons() {
      /*console.log("Setup btn listeners...");*/
      if (!document.getElementById("pronounce").onclick) document.getElementById("pronounce").onclick = pronounceWord;
      if (!document.getElementById("checkAnswer").onclick) document.getElementById("checkAnswer").onclick = checkSpelling;
      if (!document.getElementById("showAnswer").onclick) document.getElementById("showAnswer").onclick = showAnswer;
      /*console.log("Btn listeners done.");*/
    }

    // --- INITIALIZATION ---
    function startGame() {
      console.log("---- Starting Game ----");
      if (document.getElementById('keyboard').children.length === 0) {
        setupKeyboard();
        setupButtons();
        setupKeyboardShortcuts();
        setupMascotTap();
      } else {
        console.log("Skipping setup.");
      }
      loadGameState();
      if (!levelStates[currentLevel]) {
        console.warn(`No state level ${currentLevel}. Init.`);
        initializeLevelState(currentLevel);
      }
      if (levelStates[currentLevel] && levelStates[currentLevel].wordIndices && levelStates[currentLevel].wordIndices.length > 0) {
        showWord();
      } else {
        console.error("Start fail: No words level", currentLevel);
        alert("Error starting game. Could not load words.");
        document.getElementById("mainContent").style.display = "none";
      }
      console.log("---- Game Started ----");
    }

    // --- DOMContentLoaded Listener (Entry Point) ---
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM loaded.");
      const wordsScript = document.querySelector('script[src="https://geniusjazz.github.io/spelling-bee/words_full.js"]');

      // Function to run after words are confirmed loaded
      const initGame = () => {
        // Ensure startGame only runs once
        if (document.getElementById('keyboard') && document.getElementById('keyboard').children.length > 0) {
          // console.log("Initialization check: Game seems already started."); // Reduce noise
          return;
        }
        startGame();
      };

      if (typeof words !== 'undefined' && Array.isArray(words) && words.length > 0) {
        console.log("Global 'words' array found immediately:", words.length);
        initGame();
      } else if (wordsScript) {
        console.log("Waiting for words_full.js to load via script tag...");
        wordsScript.onload = () => {
          if (typeof words !== 'undefined' && Array.isArray(words) && words.length > 0) {
            console.log("words_full.js loaded successfully via onload:", words.length);
            initGame();
          } else {
            console.error("words_full.js onload fired, but 'words' array is still missing or invalid!");
            alert("Error: Word list loaded incorrectly. Please refresh.");
          }
        };
        wordsScript.onerror = () => {
          console.error("Failed to load words_full.js!");
          alert("Error: Could not load word list. Please check your internet connection and refresh the page.");
          document.getElementById("mainContent").innerHTML = "<p style='color:red; font-weight:bold;'>Failed to load word list. Game cannot start.</p>";
        };

        // Fallback check
        setTimeout(() => {
          if (typeof words !== 'undefined' && Array.isArray(words) && words.length > 0) {
            // Words loaded, but maybe onload didn't fire or game didn't start?
            if (!document.getElementById('keyboard') || document.getElementById('keyboard').children.length === 0) {
              console.log("Words found after delay, manually starting game if needed.");
              initGame();
            }
          } else {
            // Only show error if the game hasn't started by other means
            if (!document.getElementById('keyboard') || document.getElementById('keyboard').children.length === 0) {
              console.warn("Still no 'words' array after 1.5 second. Script might have failed silently.");
              // Consider showing a non-alert message in the UI instead
              document.getElementById("mainContent").innerHTML = "<p style='color:red; font-weight:bold;'>Word list loading timed out. Please refresh.</p>";
            }
          }
        }, 1500); // Increased timeout slightly

      } else {
        console.error("Critical Error: Could not find the words_full.js script tag in the HTML!");
        alert("Critical Error: Word list script tag not found. Please check the HTML source.");
        document.getElementById("mainContent").innerHTML = "<p style='color:red; font-weight:bold;'>Word list script missing. Game cannot start.</p>";
      }
    });
  </script>
</body>
</html>
