<!DOCTYPE html>
<html>
<head>
  <title>Spelling Bee Adventure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      font-family: 'Comic Neue', cursive !important;
    }

    body {
      text-align: center;
      padding: 20px;
      background: url('https://subtlepatterns.com/patterns/honey_im_subtle.png') #fff9e6;
      margin: 0;
      color: #333;
      min-height: 100vh;
    }

    #header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background: rgba(255, 235, 59, 0.7);
      border-bottom: 3px solid #f06292;
      margin-bottom: 20px;
    }

    #pronounce-toggle button {
      padding: 8px 15px;
      font-size: 16px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: background 0.3s;
    }

    #pronounce-toggle button.off {
      background: #f44336;
    }

    #wordListButton,
    #resetButton {
      width: 120px;
      background: #9c27b0;
      padding: 10px 15px;
      font-size: 16px;
      opacity: 0.7;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    #resetButton {
      background: #f44336;
    }

    #wordListButton:hover,
    #resetButton:hover {
      opacity: 1;
    }

    h1 {
      font-size: 48px;
      color: #e91e63;
      text-shadow: 2px 2px #ffeb3b;
      animation: bounce 2s infinite;
      margin-top: 20px;
    }

    #progress {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 20px 0;
      height: 40px;
    }

    .bee {
      width: 40px;
      height: 40px;
      background: url('https://img.icons8.com/ios-filled/50/ffeb3b/bee.png') no-repeat center;
      background-size: contain;
      margin-left: 10px;
    }

    #progress-bar-container {
      width: 90%;
      max-width: 400px;
      height: 20px;
      background: #ccc;
      border-radius: 10px;
      overflow: hidden;
      margin: 0 auto 10px auto;
    }

    #progress-bar {
      height: 100%;
      background: #4caf50;
      width: 0%;
      transition: width 0.5s ease;
    }

    #progress-text {
      font-size: 20px;
      color: #d81b60;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #part,
    #definition,
    #wordIndex {
      font-size: 24px;
      margin: 15px 0;
      color: #d81b60;
      background: rgba(255, 235, 59, 0.7);
      padding: 10px;
      border-radius: 15px;
      display: inline-block;
    }

    #wordDisplay {
      width: 90%;
      max-width: 450px;
      padding: 20px;
      font-size: 28px;
      margin: 20px auto;
      background: #ffffff;
      border: 4px dashed #2196f3;
      border-radius: 20px;
      min-height: 30px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      transition: opacity 0.3s ease;
    }

    #wordDisplay.fade {
      opacity: 0;
    }

    button {
      padding: 20px 30px;
      font-size: 26px;
      margin: 15px auto;
      display: block;
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      touch-action: manipulation;
      transition: transform 0.2s;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }

    button:hover:not(:disabled) {
      transform: scale(1.1);
    }

    button:active:not(:disabled) {
      transform: scale(0.95);
    }

    select {
      width: 90%;
      max-width: 300px;
      padding: 15px;
      font-size: 24px;
      margin: 15px auto;
      display: block;
      background: #ffeb3b;
      color: #d81b60;
      border: 3px solid #f06292;
      border-radius: 20px;
      cursor: pointer;
    }

    button:disabled,
    select:disabled {
      /* General disabled style removed */
    }

    #pronounce:disabled {
      background-color: #cccccc !important;
      cursor: not-allowed;
      box-shadow: none;
      opacity: 0.6;
    }

    #pronounce {
      width: 90%;
      max-width: 350px;
      background: #4caf50;
    }

    #checkAnswer {
      width: 90%;
      max-width: 350px;
      background: #ff9800;
    }

    #showAnswer {
      width: 90%;
      max-width: 350px;
      background: #2196f3;
      display: none;
    }

    #showAnswer:disabled {
      background-color: #cccccc !important;
      cursor: not-allowed;
      box-shadow: none;
      opacity: 0.6;
    }

    #keyboard {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 700px;
      margin: 20px auto;
    }

    .key {
      width: 60px;
      height: 60px;
      margin: 8px;
      font-size: 24px;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 3px solid #1976d2;
      border-radius: 15px;
      cursor: pointer;
      touch-action: manipulation;
      transition: transform 0.1s;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
    }

    .key:hover:not(:disabled) {
      transform: scale(1.1);
    }

    .key:active:not(:disabled) {
      transform: scale(0.9);
    }

    .key:disabled {
      background: #cccccc;
      border-color: #aaaaaa;
      box-shadow: none;
      opacity: 0.6;
      cursor: not-allowed;
    }

    #backspace {
      width: 90px;
      background: linear-gradient(135deg, #f44336, #ef5350);
      border-color: #d32f2f;
    }

    #clear {
      width: 90px;
      background: linear-gradient(135deg, #9c27b0, #ab47bc);
      border-color: #7b1fa2;
    }

    #feedback {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      padding: 40px;
      font-size: 36px;
      font-weight: bold;
      color: white;
      border-radius: 30px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      animation: popIn 0.5s ease-out;
    }

    #feedback.wrong {
      background: #f44336;
      border: 5px solid #c62828;
    }

    #celebration,
    #level-complete {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      pointer-events: none;
    }

    .celebration-text,
    .level-complete-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #ffffff;
      text-shadow: 2px 2px 4px #000000;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      text-align: center;
    }

    .level-complete-text span:first-child {
      font-size: 72px;
      color: #ffeb3b;
      animation: pulse 1s infinite;
    }

    .level-complete-text span:last-child {
      font-size: 36px;
      color: #ffffff;
    }

    .star {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #ffeb3b;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: spin 1.5s linear infinite;
    }

    .balloon {
      position: absolute;
      width: 30px;
      height: 40px;
      background: #f06292;
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      animation: float 2s ease-in-out infinite;
    }

    .firework {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #2196f3;
      border-radius: 50%;
      animation: explode 1s ease-out forwards;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff9800;
      transform: rotate(45deg);
      animation: fall 2s linear forwards;
    }

    #mascot {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 100px;
      height: 100px;
      background: url('https://img.icons8.com/ios-filled/100/000000/bee.png') no-repeat center;
      background-size: contain;
      transition: transform 0.5s;
      cursor: pointer;
      z-index: 10;
    }

    #mascot.happy {
      transform: scale(1.2) rotate(10deg);
    }

    #mascot.sad {
      transform: scale(0.9) rotate(-10deg);
    }

    #confirmPopup,
    #resetConfirmPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 235, 59, 0.9);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      text-align: center;
      max-width: 80%;
      animation: popIn 0.5s ease-out;
    }

    #confirmPopup p,
    #resetConfirmPopup p {
      font-size: 28px;
      color: #d81b60;
      margin: 0 0 20px 0;
    }

    #confirmPopup button,
    #resetConfirmPopup button {
      width: 140px;
      padding: 10px;
      font-size: 18px;
      margin: 5px;
      display: inline-block;
    }

    #confirmYes { background: #4caf50; }
    #confirmNo { background: #f44336; }
    #resetAll { background: #f44336; }
    #resetLevel { background: #ff9800; }
    #addStar { background: #4caf50; }
    #removeStar { background: #2196f3; }
    #resetCancel { background: #9e9e9e; }

    #review-mode {
      max-width: 700px;
      margin: 20px auto;
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    #review-mode > div {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
    }

    #passwordPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 235, 59, 0.9);
      padding: 15px;
      border-radius: 20px;
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      text-align: center;
      max-width: 360px;
      width: 90%;
      animation: popIn 0.5s ease-out;
    }

    #passwordPopup p {
      font-size: 20px;
      color: #d81b60;
      margin: 0 0 6px 0;
    }

    #passwordPopup button {
      width: 80px;
      padding: 6px;
      font-size: 14px;
      margin: 5px;
      display: inline-block;
    }

    #passwordSubmit { background: #4caf50; }
    #passwordCancel { background: #f44336; }

    /* --- Keypad Styles --- */
    #keypad {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      gap: 5px;
      max-width: 170px;
      margin: 10px auto 10px auto;
      justify-content: center;
    }

    #keypad .keypad-btn {
      width: 50px !important;
      height: 50px !important;
      font-size: 22px;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 2px solid #1976d2;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.1s;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      line-height: 50px;
      text-align: center;
      touch-action: manipulation;
    }

    #keypad .keypad-btn:hover {
      transform: scale(1.1);
    }

    #keypad .keypad-btn:active {
      transform: scale(0.9);
    }

    #keypad #keypadClear {
      background: linear-gradient(135deg, #f44336, #ef5350);
      border-color: #d32f2f;
      grid-column: 2 / 3;
    }
    /* --- End of Keypad Styles --- */

    #passwordDisplay {
      font-size: 20px;
      color: #d81b60;
      margin: 5px 0;
      min-height: 20px;
    }

    #passwordFeedback {
      font-size: 12px;
      color: #f44336;
      margin: 5px 0;
      min-height: 14px;
    }

    /* --- Watermark Style --- */
    .watermark {
      position: fixed; /* Position relative to the viewport */
      bottom: 5px;     /* Small distance from the bottom */
      left: 10px;    /* Small distance from the right */
      font-size: 20px; /* Make it small */
      color: #bbb;    /* Light gray color */
      opacity: 0.8;    /* Make it quite transparent */
      z-index: 5;      /* Keep it above most elements but below popups */
      pointer-events: none; /* Prevent it from interfering with clicks */
    }
    /* --- End Watermark Style --- */

    @keyframes shake {
      0% { transform: translate(-50%, -50%) translateX(0); }
      25% { transform: translate(-50%, -50%) translateX(-5px); }
      50% { transform: translate(-50%, -50%) translateX(5px); }
      75% { transform: translate(-50%, -50%) translateX(-5px); }
      100% { transform: translate(-50%, -50%) translateX(0); }
    }

    .shake {
      animation: shake 0.5s ease-in-out;
    }

    @media (max-width: 768px) {
      /* --- Mobile Keypad Styles --- */
      #keypad {
        grid-template-columns: repeat(3, 45px);
        gap: 4px;
        max-width: 145px;
      }

      #keypad .keypad-btn {
        width: 45px !important;
        height: 45px !important;
        font-size: 20px;
        border-radius: 8px;
        line-height: 45px;
      }
      /* --- End Mobile Keypad Styles --- */

      h1 {
        font-size: 36px;
        margin-top: 20px;
      }

      #part,
      #definition,
      #wordIndex {
        font-size: 20px;
        padding: 8px;
      }

      #wordDisplay {
        font-size: 24px;
        padding: 15px;
      }

      button,
      select {
        font-size: 22px;
        padding: 15px 25px;
      }

      #passwordPopup button {
        width: 70px;
        font-size: 12px;
        padding: 5px;
      }

      .key {
        width: 50px;
        height: 50px;
        font-size: 20px;
        margin: 5px;
      }

      #backspace,
      #clear {
        width: 70px;
      }

      #feedback {
        font-size: 28px;
        padding: 30px;
      }

      .celebration-text {
        font-size: 36px;
      }

      .level-complete-text span:first-child {
        font-size: 48px;
      }

      .level-complete-text span:last-child {
        font-size: 24px;
      }

      .star { width: 30px; height: 30px; }
      .balloon { width: 20px; height: 30px; }
      .firework, .confetti { width: 8px; height: 8px; }
      #mascot { width: 60px; height: 60px; bottom: 10px; right: 10px; }
      .bee { width: 30px; height: 30px; }
      #progress-text { font-size: 18px; }
      #header { padding: 10px; }
      #pronounce-toggle button { width: 90px; padding: 6px 10px; font-size: 12px; }
      #wordListButton, #resetButton { width: 80px; padding: 6px 10px; font-size: 12px; }
      #confirmPopup p, #resetConfirmPopup p { font-size: 24px; }
      #confirmPopup button, #resetConfirmPopup button { width: 100px; font-size: 18px; padding: 12px; }
      .word-button { font-size: 22px; padding: 8px 15px; } /* Style from wordlist.html */
      .redo-button { font-size: 20px; padding: 12px 25px; } /* Style from wordlist.html */
      #passwordPopup { max-width: 320px; padding: 10px; }
      #passwordPopup p { font-size: 18px; }
      #passwordDisplay { font-size: 18px; margin: 4px 0; }
      #passwordFeedback { font-size: 10px; margin: 4px 0; }
      .watermark { right: 5px; bottom: 2px; } /* Adjust watermark for mobile */
    }
    /* --- End of media query --- */

    .word-button { /* Style from wordlist.html - reused for review mode */
      padding: 10px 20px;
      font-size: 28px;
      font-weight: bold;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 4px solid #1976d2;
      border-radius: 15px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .word-button:hover { transform: scale(1.1); box-shadow: 0 6px 12px rgba(0,0,0,0.4); }
    .word-button:active { transform: scale(0.95); }

    .redo-button { /* Style from wordlist.html - reused for review mode */
      padding: 15px 30px;
      font-size: 26px;
      background: linear-gradient(135deg, #4caf50, #66bb6a);
      color: white;
      border: 4px solid #388e3c;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      margin-top: 20px;
    }
    .redo-button:hover { transform: scale(1.1); box-shadow: 0 6px 12px rgba(0,0,0,0.4); }
    .redo-button:active { transform: scale(0.95); }

    /* --- Animations --- */
    @keyframes bounce { 0%, 20%, 50%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-15px); } 60% { transform: translateY(-10px); } }
    @keyframes popIn { 0% { transform: translate(-50%, -50%) scale(0); opacity: 0; } 80% { transform: translate(-50%, -50%) scale(1.15); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
    @keyframes spin { 0% { transform: rotate(0deg) scale(1); } 50% { transform: rotate(180deg) scale(1.2); } 100% { transform: rotate(360deg) scale(1); } }
    @keyframes float { 0% { transform: translateY(0); } 50% { transform: translateY(-20px); } 100% { transform: translateY(0); } }
    @keyframes explode { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(10); opacity: 0; } }
    @keyframes fall { 0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(360deg); opacity: 0; } }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    /* --- End Animations --- */

  </style>
</head>
<body>
  <div id="header">
    <div id="pronounce-toggle">
      <button id="fullPronounce" onclick="togglePronounce()">Full Pronunciation: On</button>
    </div>
    <button id="wordListButton" onclick="showConfirmPopup()">Word List</button>
    <button id="resetButton" onclick="showResetConfirmPopup()">Reset Progress</button>
  </div>

  <h1>Spelling Bee Adventure</h1>

  <div id="mainContent">
    <select id="levelSelect" onchange="changeLevel()">
      <option value="0">Level 1-a</option>
      <option value="1">Level 1-b</option>
      <option value="2">Level 1-c</option>
      <option value="3">Level 1-d</option>
      <option value="4">Level 1-e</option>
      <option value="5">Level 2-a</option>
      <option value="6">Level 2-b</option>
      <option value="7">Level 2-c</option>
      <option value="8">Level 2-d</option>
      <option value="9">Level 2-e</option>
      <option value="10">Level 3-a</option>
      <option value="11">Level 3-b</option>
      <option value="12">Level 3-c</option>
      <option value="13">Level 3-d</option>
      <option value="14">Level 3-e</option>
      <option value="15">Level 4</option>
      <option value="16">Level 5</option>
      <option value="17">Level 6</option>
      <option value="18">Level 7</option>
      <option value="19">Level 8</option>
      <option value="20">Level 9</option>
    </select>

    <div id="progress"></div>
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>
    <div id="progress-text">Words Completed: 0/10 <div class="bee"></div></div>

    <div id="part"></div>
    <div id="definition"></div>
    <div id="wordIndex"></div>

    <button id="pronounce" onclick="pronounceWord()">Pronounce</button>
    <div id="wordDisplay"></div>
    <div id="keyboard"></div>

    <button id="checkAnswer" onclick="checkSpelling()">Check Answer</button>
    <button id="showAnswer" onclick="showAnswer()">Show Answer</button>
  </div>

  <div id="feedback" onclick="hideFeedback()"></div>
  <div id="celebration"><div class="celebration-text">🎉 Great Job! 🎉</div></div>
  <div id="level-complete"><div class="level-complete-text"><span>🎉 Level Complete! 🎉</span><span></span></div></div>
  <div id="mascot"></div>

  <div id="confirmPopup">
    <p>Want to peek at the word list?</p>
    <button id="confirmYes" onclick="goToWordList()">Yes</button>
    <button id="confirmNo" onclick="hideConfirmPopup()">No</button>
  </div>

  <div id="passwordPopup">
    <p>Enter Password to Reset:</p>
    <div id="passwordDisplay"></div>
    <div id="passwordFeedback"></div>
    <div id="keypad">
      <button class="keypad-btn" onclick="appendPasswordDigit('1')">1</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('2')">2</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('3')">3</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('4')">4</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('5')">5</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('6')">6</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('7')">7</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('8')">8</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('9')">9</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('0')">0</button>
      <button id="keypadClear" class="keypad-btn" onclick="clearPassword()">Clear</button>
    </div>
    <button id="passwordSubmit" onclick="checkPassword()">Submit</button>
    <button id="passwordCancel" onclick="hidePasswordPopup()">Cancel</button>
  </div>

  <div id="resetConfirmPopup">
    <p>Reset Options:</p>
    <button id="resetAll" onclick="resetAllProgress()">Reset All Progress</button>
    <button id="resetLevel" onclick="resetCurrentLevel()">Reset Current Level</button>
    <button id="addStar" onclick="addStarToLevel()">Add Star</button>
    <button id="removeStar" onclick="removeStarFromLevel()">Remove Star</button>
    <button id="resetCancel" onclick="hideResetConfirmPopup()">Cancel</button>
  </div>

  <div id="review-mode">
    </div>

  <script src="https://geniusjazz.github.io/spelling-bee/words_full.js"></script>
  <script>
    'use strict'; // Enable strict mode

    // Game State Variables
    let currentLevel = 0;
    let levelStates = {}; // Stores state per level { failCount, wordsCompleted, wordIndices, indexPointer, isReviewMode, missedWords, currentIndex, currentWord }
    let levelCompletions = {}; // Stores completion counts { levelIndex: count }
    let lastPronouncedIndex = -1; // Tracks the last word index fully pronounced
    let isSpeaking = false; // Flag to prevent overlapping speech
    let tapCount = 0; // Counter for mascot taps
    let tapTimeout; // Timeout for mascot taps
    let fullPronounceEnabled = true; // Toggle for full pronunciation details
    let currentPassword = ""; // For reset popup

    // --- UTILITY FUNCTIONS ---
    function shuffle(array) {
      // Fisher-Yates (aka Knuth) Shuffle
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function playSound(type) {
      // Creates and plays a short sound effect
      const audio = new Audio();
      if (type === 'correct') audio.src = 'https://www.soundjay.com/buttons/sounds/button-3.mp3';
      else if (type === 'wrong') audio.src = 'https://www.soundjay.com/buttons/sounds/beep-03.mp3';
      else if (type === 'levelComplete') audio.src = 'https://www.soundjay.com/human/sounds/cheering-01.mp3';
      audio.volume = 0.6; // Slightly lower volume
      audio.play().catch((err) => console.warn(`Sound ${type} failed to play:`, err)); // Log errors quietly
    }

    // --- STATE MANAGEMENT (LocalStorage) ---
    function saveGameState() {
      // Saves current level index, state object for current level, all completion counts, and pronounce setting
      if (!levelStates[currentLevel]) {
        /*console.warn("Save state: Attempted to save uninitialized level:", currentLevel);*/
        return; // Don't save if state doesn't exist
      }
      const state = levelStates[currentLevel];
      // Create a clean object with only persistent data
      const stateToSave = {
        failCount: state.failCount ?? 0,
        wordsCompleted: state.wordsCompleted ?? 0,
        wordIndices: state.wordIndices ?? [],
        indexPointer: state.indexPointer ?? 0,
        isReviewMode: state.isReviewMode ?? false,
        missedWords: state.missedWords ?? [], // Save missed words (array of word objects)
      };
      try {
        localStorage.setItem('currentLevel', currentLevel); // Save current level index
        localStorage.setItem(`levelState_${currentLevel}`, JSON.stringify(stateToSave)); // Save state for this level
        localStorage.setItem('levelCompletions', JSON.stringify(levelCompletions)); // Save all completion counts
        localStorage.setItem('fullPronounceEnabled', fullPronounceEnabled); // Save pronunciation preference
      } catch (e) {
        console.error("Error saving game state to localStorage:", e);
        // Potentially notify user if storage is full or blocked
      }
    }

    function loadGameState() {
      // Loads game state from localStorage on page load
      console.log("Loading game state...");
      try {
        currentLevel = parseInt(localStorage.getItem('currentLevel')) || 0; // Default to level 0 if not found
        levelCompletions = JSON.parse(localStorage.getItem('levelCompletions')) || {}; // Default to empty object
        fullPronounceEnabled = localStorage.getItem('fullPronounceEnabled') !== 'false'; // Default to true

        levelStates = {}; // Reset in-memory states before loading
        // Iterate through potential levels to load saved states
        for (let i = 0; i < 21; i++) { // Assuming max level index 20 (adjust if more levels)
          const storedState = localStorage.getItem(`levelState_${i}`);
          if (storedState) {
            try {
              levelStates[i] = JSON.parse(storedState);
              // Add back transient properties needed at runtime but not saved
              levelStates[i].currentIndex = (levelStates[i].wordIndices && levelStates[i].wordIndices.length > levelStates[i].indexPointer)
                                            ? levelStates[i].wordIndices[levelStates[i].indexPointer]
                                            : 0; // Current word index within the level's list
              levelStates[i].currentWord = ""; // User's current input (always starts empty)
            } catch (parseError) {
              console.error(`Error parsing saved state for level ${i}:`, parseError);
              localStorage.removeItem(`levelState_${i}`); // Remove corrupted data
            }
          }
        }

        // Update UI based on loaded state
        const levelSelect = document.getElementById("levelSelect");
        if(levelSelect) levelSelect.value = currentLevel; // Set dropdown to loaded level
        updatePronounceButton();
        updateLevelSelect(); // Update dropdown text with stars/trophies

        // Initialize state for the current level if it wasn't loaded
        if (!levelStates[currentLevel]) {
          console.log(`Initializing state for level ${currentLevel} as none was loaded.`);
          initializeLevelState(currentLevel);
        } else {
          console.log(`Loaded state for level ${currentLevel}:`, levelStates[currentLevel]);
        }
      } catch (e) {
        console.error("Error loading game state from localStorage:", e);
        // Reset to defaults in case of major loading error
        currentLevel = 0;
        levelStates = {};
        levelCompletions = {};
        fullPronounceEnabled = true;
        initializeLevelState(currentLevel); // Initialize level 0
        updateLevelSelect();
      }
    }

    function initializeLevelState(level) {
      // Sets up a fresh state object for a given level index
      console.log(`Initializing state for level ${level}...`);
      // Preserve review mode status and missed words if re-initializing during review setup
      const isReview = levelStates[level]?.isReviewMode || false;
      const missed = levelStates[level]?.missedWords || [];

      levelStates[level] = {
        failCount: 0,             // Incorrect attempts for the current word
        wordsCompleted: 0,        // Words correctly spelled in this session/mode
        wordIndices: [],          // Shuffled array of indices for the level's words
        indexPointer: 0,          // Points to the current index in wordIndices
        isReviewMode: isReview,   // Is the level currently in review mode?
        missedWords: isReview ? missed : [], // Array of word objects missed in normal mode
        currentIndex: 0,          // Index of the current word within the source list (levelWords or missedWords)
        currentWord: ""           // User's current typed input
      };
      initializeWordIndices(level); // Create and shuffle word indices for the level
      // Note: saveGameState() is called within initializeWordIndices after indices are set
    }

    function initializeWordIndices(level) {
      // Creates and shuffles the word index array for the current level/mode
      if (!levelStates[level]) {
        console.error("initializeWordIndices called with no state for level:", level);
        return; // Cannot proceed without state
      }
      const state = levelStates[level];
      const levelWords = getLevelWords(); // Gets the base word objects for the level/mode

      let sourceArray; // Array whose indices we will shuffle

      if (state.isReviewMode) {
        // In review mode, use the missedWords array
        sourceArray = state.missedWords;
        if (!sourceArray || sourceArray.length === 0) {
          console.warn(`Review mode started for level ${level}, but no missed words found. Completing level.`);
          state.isReviewMode = false; // Exit review mode
          saveGameState(); // Save the state change
          endReviewMode(true); // Force level completion immediately
          return; // Stop initialization
        }
        console.log(`Initializing indices for level ${level} (Review Mode - ${sourceArray.length} words)`);
      } else {
        // In normal mode, use the words for the current level
        sourceArray = levelWords;
        if (!sourceArray || sourceArray.length === 0) {
          console.error(`No words found for level ${level} in normal mode.`);
          // Handle error gracefully - maybe disable game or prompt user
           alert(`Error: Could not load words for Level ${level + 1}. Please try another level or refresh.`);
           // Optionally disable buttons here
          return; // Stop initialization
        }
        console.log(`Initializing indices for level ${level} (Normal Mode - ${sourceArray.length} words)`);
      }

      // Create an array of indices [0, 1, 2, ..., n-1] and shuffle it
      state.wordIndices = shuffle(Array.from({ length: sourceArray.length }, (_, i) => i));

      // Reset runtime properties for the new word list
      state.indexPointer = 0;
      state.currentWord = "";
      state.failCount = 0; // Reset fail count for the first word
      state.currentIndex = state.wordIndices[state.indexPointer] ?? 0; // Set initial word index
      lastPronouncedIndex = -1; // Reset pronunciation tracking

      updateProgress(); // Update UI progress bar/text
      saveGameState(); // Save the newly initialized state with shuffled indices
    }


    // --- UI UPDATES ---
    function updatePronounceButton() {
      // Updates the text and class of the full pronunciation toggle button
      const btn = document.getElementById("fullPronounce");
      if(btn) {
         btn.innerText = `Full Pronunciation: ${fullPronounceEnabled ? 'On' : 'Off'}`;
         btn.className = fullPronounceEnabled ? '' : 'off';
      }
    }

    function updateLevelSelect() {
      // Updates the text of options in the level select dropdown to show stars/trophies
      const sel = document.getElementById("levelSelect");
      if (!sel) return;
      // Base names for the levels - should match the option values/order
      const baseLevelNames = [ "Level 1-a","Level 1-b","Level 1-c","Level 1-d","Level 1-e","Level 2-a","Level 2-b","Level 2-c","Level 2-d","Level 2-e","Level 3-a","Level 3-b","Level 3-c","Level 3-d","Level 3-e","Level 4","Level 5","Level 6","Level 7","Level 8","Level 9" ];

      for (let i = 0; i < sel.options.length; i++) {
         if (i >= baseLevelNames.length) break; // Stop if we run out of base names

         const option = sel.options[i];
         const levelIndex = parseInt(option.value); // Get level index from option value
         const baseName = baseLevelNames[i]; // Get base name

         const completions = levelCompletions[levelIndex] || 0; // Get completions for this level
         const stars = completions % 5; // Calculate stars (1-4)
         const trophies = Math.floor(completions / 5); // Calculate trophies (5 completions = 1 trophy)

         let suffix = ''; // Build the suffix string
         if (trophies > 0) suffix += ' 🏆'.repeat(trophies);
         if (stars > 0) suffix += ' ⭐'.repeat(stars);

         option.text = baseName + suffix; // Set the option's display text
      }
    }

    function updateDisplay() {
      // Updates the word display area with the current user input
      const wordDisplay = document.getElementById("wordDisplay");
      if (!wordDisplay || !levelStates[currentLevel]) return;
      wordDisplay.innerText = levelStates[currentLevel].currentWord || ""; // Show current input or empty string
    }

    function updateProgress() {
      // Updates the progress bar and text
      if (!levelStates[currentLevel]) return; // Need state to update progress
      const state = levelStates[currentLevel];
      const progressBar = document.getElementById("progress-bar");
      const progressText = document.getElementById("progress-text");

      if (!progressBar || !progressText) return; // Ensure elements exist

      let totalWordsInLevel = 0;
      if (state.isReviewMode) {
        // Total words in review mode is the number of initially missed words
        totalWordsInLevel = state.missedWords?.length || 0;
      } else {
        // Total words in normal mode depends on the level index
        totalWordsInLevel = (currentLevel < 15) ? 10 : 50; // Levels 1-3 have 10, Levels 4+ have 50
      }

      // Calculate percentage, avoid division by zero
      const percentage = totalWordsInLevel > 0 ? (state.wordsCompleted / totalWordsInLevel) * 100 : 0;

      progressBar.style.width = `${percentage}%`; // Set progress bar width
      // Update progress text, including the bee icon
      progressText.innerHTML = `Words Completed: ${state.wordsCompleted}/${totalWordsInLevel} <div class="bee"></div>`;
    }

    function showFeedback(message, isCorrect) {
      // Displays feedback message (e.g., "Correct!", "Try Again!") and updates mascot appearance
      const feedbackElement = document.getElementById("feedback");
      const mascotElement = document.getElementById("mascot");
      if (!feedbackElement || !mascotElement) return;

      feedbackElement.innerText = message;
      feedbackElement.className = isCorrect ? "" : "wrong"; // Add 'wrong' class for incorrect feedback styling
      feedbackElement.style.display = message ? "block" : "none"; // Show only if there's a message
      mascotElement.className = isCorrect ? "happy" : "sad"; // Set mascot class

      // Automatically hide incorrect feedback after a delay
      if (!isCorrect && message) {
        setTimeout(() => {
          // Check if the feedback element is still showing the *same* message before hiding
          if (feedbackElement.innerText === message && feedbackElement.style.display === 'block') {
            feedbackElement.style.display = "none";
            mascotElement.className = ""; // Reset mascot
          }
        }, 1500); // 1.5 second delay
      } else if (isCorrect) {
          // If correct, mascot stays happy until next action implicitly resets it (e.g., nextWord)
      }
    }

    function hideFeedback() {
      // Manually hides the feedback message and resets the mascot (e.g., if user clicks feedback)
      const feedbackElement = document.getElementById("feedback");
      const mascotElement = document.getElementById("mascot");
      if (feedbackElement) feedbackElement.style.display = "none";
      if (mascotElement) mascotElement.className = "";
    }

    // --- GAME LOGIC ---
    function getLevelWords() {
      // Returns the array of word *objects* for the current level/mode
      const state = levelStates[currentLevel];
      if (!state) {
        console.error("getLevelWords: No state found for current level:", currentLevel);
        return []; // Return empty array if state is missing
      }

      // If in review mode, return the missed words array stored in the state
      if (state.isReviewMode) {
        return state.missedWords || []; // Return missed words or empty array if none
      }

      // If in normal mode, calculate the slice from the global 'words' array
      let startIndex;
      if (currentLevel < 5) startIndex = currentLevel * 10;        // Levels 1-a to 1-e (0-4) -> indices 0-49
      else if (currentLevel < 10) startIndex = 50 + (currentLevel - 5) * 10; // Levels 2-a to 2-e (5-9) -> indices 50-99
      else if (currentLevel < 15) startIndex = 100 + (currentLevel - 10) * 10;// Levels 3-a to 3-e (10-14) -> indices 100-149
      else startIndex = 150 + (currentLevel - 15) * 50; // Levels 4-9 (15-20) -> indices 150+

      const wordCount = currentLevel < 15 ? 10 : 50; // Number of words per level

      // Ensure the global 'words' array exists and is an array
      if (typeof words === 'undefined' || !Array.isArray(words)) {
        console.error("Global 'words' array is missing or not an array!");
        return [];
      }

      // Check if start index is valid
      if (startIndex >= words.length) {
        console.warn(`Calculated start index (${startIndex}) is out of bounds for words array (length ${words.length}) for level ${currentLevel}.`);
        return [];
      }

      // Slice the global words array, ensuring not to exceed its bounds
      return words.slice(startIndex, Math.min(startIndex + wordCount, words.length));
    }

    function showWord() {
      // Displays the definition, part of speech, etc., for the current word
      // console.log("---- showWord ----"); // Reduce console noise

      // Ensure state exists, initialize if needed (should ideally be handled by load/changeLevel)
      if (!levelStates[currentLevel]) {
        console.error(`showWord: State missing for level ${currentLevel}. Attempting initialization.`);
        initializeLevelState(currentLevel);
        if (!levelStates[currentLevel]) {
          alert("Critical Error: Failed to initialize level state.");
          return; // Cannot proceed
        }
      }
      const state = levelStates[currentLevel];
      const currentWordList = getLevelWords(); // Get words for the current level/mode

      // Validate the word list
      if (!currentWordList || currentWordList.length === 0) {
        console.error("showWord: No words returned for level/mode:", currentLevel, state.isReviewMode);
        if (state.isReviewMode) {
          console.log("No review words left, attempting to end review mode.");
          endReviewMode(true); // End review if list is empty
        } else {
          alert(`Error: No words found for this Level. Please select another level.`);
        }
        return; // Stop processing
      }

      // Validate word indices and pointer
      if (!state.wordIndices || state.wordIndices.length === 0 || state.indexPointer >= state.wordIndices.length) {
        console.warn("showWord: Word indices issue detected. Re-initializing indices for level:", currentLevel);
        initializeWordIndices(currentLevel); // Attempt to fix by re-shuffling
        // Check again after re-initialization
        if (!state.wordIndices || state.wordIndices.length === 0 || state.indexPointer >= state.wordIndices.length) {
           console.error("showWord: Failed to re-initialize indices. Cannot display word.");
           alert("Error displaying word. Please try changing levels.");
           return;
        }
      }

      // Get the actual index from the shuffled list
      const wordIndexInSource = state.wordIndices[state.indexPointer];

      // Validate the index against the current word list
      if (wordIndexInSource < 0 || wordIndexInSource >= currentWordList.length) {
        console.error("showWord: Derived word index is out of bounds.", { pointer: state.indexPointer, derivedIndex: wordIndexInSource, listLength: currentWordList.length });
        initializeWordIndices(currentLevel); // Attempt to fix
        return; // Try again after re-initializing
      }

      // Get the word data object
      const wordData = currentWordList[wordIndexInSource];

      // Validate the word data object itself
      if (!wordData || typeof wordData.word !== 'string' || typeof wordData.part !== 'string' || typeof wordData.definition !== 'string' || typeof wordData.no === 'undefined') {
        console.error("showWord: Invalid or incomplete word data retrieved:", { wordIndexInSource, wordData });
        alert("Error: Corrupted word data encountered. Skipping word.");
        // Skip this word automatically (or implement other error handling)
        nextWord(); // Move to the next word
        return;
      }

      // --- Update UI Elements ---
      state.currentIndex = wordIndexInSource; // Store the *actual* index within the currentWordList
      console.log(`Displaying Word: Pointer=${state.indexPointer}, ListIndex=${state.currentIndex}, Word=${wordData.word}`);

      // Get UI elements
      const partElement = document.getElementById("part");
      const definitionElement = document.getElementById("definition");
      const wordIndexElement = document.getElementById("wordIndex");
      const showAnswerButton = document.getElementById("showAnswer");
      const mainContent = document.getElementById("mainContent");
      const reviewModeDiv = document.getElementById("review-mode");
      const mascotElement = document.getElementById("mascot");
      const checkAnswerButton = document.getElementById("checkAnswer");
      const levelSelect = document.getElementById("levelSelect");
      const pronounceButton = document.getElementById("pronounce");

      // Update text content
      if (partElement) partElement.innerText = "Part of Speech: " + wordData.part;
      if (definitionElement) definitionElement.innerText = "Definition: " + wordData.definition;
      if (wordIndexElement) wordIndexElement.innerText = "Word #" + wordData.no; // Display original word number

      // Reset user input and display
      state.currentWord = "";
      updateDisplay();

      // Show/hide the "Show Answer" button based on fail count
      if (showAnswerButton) {
        showAnswerButton.style.display = state.failCount >= 3 ? "block" : "none";
        showAnswerButton.disabled = state.failCount < 3; // Enable/disable accordingly
      }

      // Ensure main game content is visible and review mode is hidden
      if (mainContent) mainContent.style.display = "block";
      if (reviewModeDiv) reviewModeDiv.style.display = "none";

      // Reset mascot appearance
      if (mascotElement) mascotElement.className = "";

      // Update progress display
      updateProgress();

      // Ensure controls are enabled (pronounce button state depends on isSpeaking)
      if (checkAnswerButton) checkAnswerButton.disabled = false;
      if (levelSelect) levelSelect.disabled = false;
      document.querySelectorAll('.key').forEach(key => key.disabled = false); // Enable keyboard keys
      if (pronounceButton) pronounceButton.disabled = isSpeaking; // Disable only if currently speaking
    }

    function changeLevel() {
      // Handles selection change in the level dropdown
      // Cancel any ongoing speech
      if (isSpeaking) {
        console.log("Level changed - cancelling speech.");
        speechSynthesis.cancel();
        isSpeaking = false;
        enableButtons(); // Ensure pronounce button is re-enabled
      }

      const levelSelect = document.getElementById("levelSelect");
      if(!levelSelect) return; // Should not happen

      const newLevel = parseInt(levelSelect.value);
      console.log("Changing level to:", newLevel);

      // Save state of the *previous* level before switching
      saveGameState();

      // Set the new current level
      currentLevel = newLevel;
      // localStorage.setItem('currentLevel', currentLevel); // Save immediately (or rely on next saveGameState)

      // Initialize state if it doesn't exist for the new level
      if (!levelStates[currentLevel]) {
        initializeLevelState(currentLevel);
      } else {
        // If state exists, reset volatile parts like current input
        levelStates[currentLevel].currentWord = "";
        // Optional: Reset failCount and lastPronouncedIndex if desired on level switch
        // levelStates[currentLevel].failCount = 0;
        // lastPronouncedIndex = -1;
        console.log("Loaded existing state for switched level:", newLevel);
      }

      // Display the first word of the new level
      showWord();
      // No need to explicitly save here, actions within showWord/initializeLevelState handle saves.
    }

    function checkSpelling() {
      // Checks the user's input against the correct spelling
      // Cancel any ongoing speech
      if (isSpeaking) {
        console.log("Check Answer clicked - cancelling speech.");
        speechSynthesis.cancel();
        isSpeaking = false;
        enableButtons(); // Re-enable pronounce button
      }

      // Validate state and current word index
      if (!levelStates[currentLevel]) {
        console.error("checkSpelling: No state found for current level.");
        return;
      }
      const state = levelStates[currentLevel];
      const currentWordList = getLevelWords();
      if (state.currentIndex < 0 || !currentWordList || state.currentIndex >= currentWordList.length) {
        console.error("checkSpelling: Invalid current word index or word list.", state.currentIndex);
        showWord(); // Attempt to recover by showing the word again
        return;
      }

      const correctWord = currentWordList[state.currentIndex].word.toLowerCase(); // Get correct word, lowercase
      const userInput = state.currentWord.trim().toLowerCase(); // Get user input, trim whitespace, lowercase
      console.log("Checking Spelling:", { Input: userInput, Correct: correctWord });

      if (userInput === correctWord) {
        // --- CORRECT ANSWER ---
        state.wordsCompleted++; // Increment completed count for the level/mode
        playSound('correct');
        showFeedback("✅ Correct!", true); // Show positive feedback
        // Disable buttons temporarily during celebration
        document.getElementById("checkAnswer").disabled = true;
        document.getElementById("pronounce").disabled = true;
        showCelebration(); // Trigger celebration animation (which calls nextWord on completion)
        // saveGameState(); // Save state after correct answer (or handled by nextWord flow)
      } else {
        // --- INCORRECT ANSWER ---
        state.failCount++; // Increment fail count for this word
        playSound('wrong');
        showFeedback("❌ Oops! Try Again! ❌", false); // Show negative feedback

        // If this is the first fail for this word in normal mode, add it to missedWords
        if (state.failCount === 1 && !state.isReviewMode) {
          if (!state.missedWords) state.missedWords = []; // Initialize if needed
          // Check if already added (shouldn't happen with failCount check, but good safety)
          const wordObject = currentWordList[state.currentIndex];
          if (!state.missedWords.some(missed => missed.no === wordObject.no)) {
            state.missedWords.push(wordObject); // Add the full word object
            console.log("Added to missed words:", wordObject.word);
          }
        }

        // Show/enable the "Show Answer" button after 3 fails
        const showAnswerButton = document.getElementById("showAnswer");
        if (showAnswerButton) {
            if (state.failCount >= 3) {
                showAnswerButton.style.display = "block";
                showAnswerButton.disabled = false;
            } else {
                showAnswerButton.style.display = "none";
                showAnswerButton.disabled = true;
            }
        }

        // Clear the user's input field after a wrong answer
        state.currentWord = "";
        updateDisplay();
        saveGameState(); // Save state after incorrect answer
      }
    }

    function showAnswer() {
      // Displays the correct answer in the feedback area
      // Cancel any ongoing speech
      if (isSpeaking) {
        console.log("Show Answer clicked - cancelling speech.");
        speechSynthesis.cancel();
        isSpeaking = false;
        enableButtons();
      }

      if (!levelStates[currentLevel]) return;
      const state = levelStates[currentLevel];
      const currentWordList = getLevelWords();
      if (state.currentIndex < 0 || !currentWordList || state.currentIndex >= currentWordList.length) {
        console.error("showAnswer: Invalid current word index or word list.");
        return;
      }

      const correctWord = currentWordList[state.currentIndex].word;
      showFeedback(`Answer: ${correctWord}`, false); // Show answer as negative feedback (doesn't advance game)
      // Note: This does not advance the word or count as completed.
    }

    function nextWord() {
      // Advances the game to the next word or triggers review/completion
      // console.log("---- nextWord ----"); // Reduce console noise
      hideFeedback(); // Ensure any previous feedback is hidden

      if (!levelStates[currentLevel]) {
        console.error("nextWord: No state found for current level.");
        return; // Cannot proceed
      }
      const state = levelStates[currentLevel];

      state.indexPointer++; // Move to the next index in the shuffled list

      const totalWordsInList = state.wordIndices?.length || 0;

      // Check if we've finished all words in the current list (normal or review)
      if (state.indexPointer >= totalWordsInList) {
        console.log("Finished current word list for level", currentLevel);
        if (state.isReviewMode) {
          // Finished review mode - complete the level
          console.log("Ending review mode and completing level.");
          endReviewMode(); // This handles completion logic
        } else if (state.missedWords && state.missedWords.length > 0) {
          // Finished normal mode, and there are missed words - start review
          console.log("Starting review mode for missed words.");
          showReviewMode(); // Transition to review mode UI
        } else {
          // Finished normal mode, and no words were missed - complete the level
          console.log("No missed words, completing level directly.");
          endReviewMode(true); // Force completion (no review needed)
        }
        return; // Stop further processing as we're transitioning modes or completing
      }

      // --- Prepare for the next word in the current list ---
      state.failCount = 0; // Reset fail count for the new word
      isSpeaking = false; // Ensure speaking flag is reset
      speechSynthesis.cancel(); // Cancel any residual speech
      state.currentWord = ""; // Clear user input
      lastPronouncedIndex = -1; // Reset pronunciation tracking for the new word

      // Hide "Show Answer" button
       const showAnswerButton = document.getElementById("showAnswer");
       if(showAnswerButton) showAnswerButton.style.display = "none";

      showWord(); // Display the next word
      saveGameState(); // Save state after successfully moving to the next word setup
    }

    // --- PRONUNCIATION ---
    function pronounceWord() {
      // Initiates the pronunciation sequence for the current word
      // Cancel previous speech if pronounce is clicked again quickly
      if (isSpeaking) {
        console.log("Pronounce clicked - cancelling previous speech.");
        speechSynthesis.cancel();
        isSpeaking = false; // Reset flag, finally block in sequence will re-enable button
      }

      if (!levelStates[currentLevel]) {
        console.error("pronounceWord: No state found for current level.");
        return;
      }
      const state = levelStates[currentLevel];
      const currentWordList = getLevelWords();

      // Validate word data before attempting pronunciation
      if (!currentWordList || state.currentIndex < 0 || state.currentIndex >= currentWordList.length || !currentWordList[state.currentIndex] || !currentWordList[state.currentIndex].word) {
        console.error("pronounceWord: Current word data is not ready or invalid.");
        showFeedback("Word not ready to pronounce.", false);
        return;
      }

      console.log("Pronounce button clicked - starting sequence.");
      isSpeaking = true; // Set flag *before* calling async function
      disableButtons(); // Disable *only* the pronounce button
      pronounceSequence(); // Call the async function that handles the sequence
    }

    const pronounceSequence = async () => {
      // Handles the asynchronous sequence of pronunciation (TTS, Howjsay, Details)
      if (!levelStates[currentLevel]) { console.error("pronounceSequence: State missing."); isSpeaking = false; enableButtons(); return; }
      const state = levelStates[currentLevel];
      if (!state.wordIndices || state.indexPointer >= state.wordIndices.length) { console.error("pronounceSequence: Invalid state pointer."); isSpeaking = false; enableButtons(); return; }

      const currentWordList = getLevelWords();
      if (state.currentIndex < 0 || state.currentIndex >= currentWordList.length) { console.error("pronounceSequence: Invalid word index."); isSpeaking = false; enableButtons(); return; }

      const wordData = currentWordList[state.currentIndex];
      if (!wordData || !wordData.word) { console.error("pronounceSequence: Invalid word data."); isSpeaking = false; enableButtons(); return; }

      const wordToPronounce = wordData.word.toLowerCase();
      // Determine if full details should be read (first time pronouncing this specific word index in this session)
      const shouldRunFullSequence = fullPronounceEnabled && state.currentIndex !== lastPronouncedIndex;

      try {
        // --- Pronunciation Attempt 1: Howjsay ---
        try {
          if (!isSpeaking) return; // Check cancellation
          console.log("Attempting Howjsay...");
          await playHowjsayAudio();
          console.log("Howjsay succeeded.");
        } catch (howjsayError) {
          // If cancelled, stop the sequence
          if (howjsayError?.message?.includes("Cancelled")) { console.log("Sequence cancelled during Howjsay."); isSpeaking = false; return; }
          // Otherwise, log warning and proceed to TTS fallback
          console.warn("Howjsay failed, falling back to TTS:", howjsayError?.message || howjsayError);
          if (!isSpeaking) return; // Check cancellation before fallback
          console.log("Attempting TTS fallback (1)...");
          await speakText(wordToPronounce);
        }

        if (!isSpeaking) { console.log("Sequence cancelled after attempt 1."); return; }

        // Short pause
        await new Promise(r => setTimeout(r, 250));
        if (!isSpeaking) { console.log("Sequence cancelled during pause 1."); return; }

        // --- Pronunciation Attempt 2: TTS (Always runs after first attempt) ---
        console.log("Attempting TTS (2)...");
        await speakText(wordToPronounce);
        if (!isSpeaking) { console.log("Sequence cancelled after attempt 2."); return; }

        // --- Optional Full Sequence (Definition, Part of Speech) ---
        if (shouldRunFullSequence) {
          console.log("Running full pronunciation details...");
          await new Promise(r => setTimeout(r, 800)); // Longer pause before details
          if (!isSpeaking) { console.log("Sequence cancelled before details."); return; }

          if (wordData.part) { await speakText(`Part of speech: ${wordData.part}`); }
          if (!isSpeaking) { console.log("Sequence cancelled after part of speech."); return; }

          if (wordData.definition) { await speakText(`Definition: ${wordData.definition}`); }
          if (!isSpeaking) { console.log("Sequence cancelled after definition."); return; }

          await new Promise(r => setTimeout(r, 500)); // Pause before repeat
          if (!isSpeaking) { console.log("Sequence cancelled before repeat prompt."); return; }

          await speakText("Please spell");
          if (!isSpeaking) { console.log("Sequence cancelled after repeat prompt."); return; }

          await new Promise(r => setTimeout(r, 500)); // Pause before final word
          if (!isSpeaking) { console.log("Sequence cancelled before final word."); return; }

          console.log("Attempting final TTS...");
          await speakText(wordToPronounce); // Final repetition of the word
          if (!isSpeaking) { console.log("Sequence cancelled after final word."); return; }

          lastPronouncedIndex = state.currentIndex; // Mark this word index as fully pronounced
          console.log("Full pronunciation sequence complete.");
        }

      } catch (error) {
        // Catch cancellation errors or unexpected errors from speakText/playHowjsay
        if (error?.message?.includes("Cancelled")) {
          console.log("Pronunciation sequence intentionally interrupted/cancelled.");
        } else {
          console.error("Unexpected error during pronunciation sequence:", error);
        }
      } finally {
        // This block *always* runs, ensuring cleanup
        if (isSpeaking) {
            // If the flag is still true here, it means the sequence finished normally
            // or an unexpected error occurred (cancellations should set it to false earlier).
            isSpeaking = false;
        }
        // Always re-enable the pronounce button, regardless of how the sequence ended
        enableButtons();
        console.log("Pronunciation sequence ended.");
      }
    };

    const speakText = (text) => {
      // Promisified wrapper for SpeechSynthesisUtterance
      return new Promise((resolve, reject) => {
        if (!text || typeof text !== 'string' || text.trim() === "") {
          console.warn("speakText called with invalid text.");
          return resolve(); // Resolve promise for empty text
        }
        // Check cancellation flag *before* creating utterance
        if (!isSpeaking) {
          /*console.log("speakText: Cancelled before utterance creation.");*/
          return reject(new Error("Cancelled"));
        }

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = "en-US"; // Set language
        utterance.rate = 0.7;    // Adjust rate
        utterance.pitch = 0.7;   // Adjust pitch
        let ended = false;      // Flag to prevent multiple calls
        let timer = null;       // Timeout handler

        // Function to handle resolution/rejection cleanup
        const cleanup = (error = null) => {
          clearTimeout(timer); // Clear any pending timeout
          if (ended) return;  // Prevent multiple calls
          ended = true;
          if (error) {
            // console.log(`speakText rejected for "${text}":`, error.message); // Quiet log for cancellations
            reject(error);
          } else {
            // console.log(`speakText resolved for "${text}"`);
            resolve();
          }
        };

        utterance.onend = () => cleanup(); // Speech finished successfully

        utterance.onerror = (event) => {
          // Handle specific error types
          if (event.error === 'interrupted' || event.error === 'canceled') {
             cleanup(new Error("Cancelled")); // Treat browser interruption/cancellation as our cancellation
          } else {
             console.error(`SpeechSynthesis Error for "${text}":`, event.error);
             cleanup(new Error(`TTS Error: ${event.error}`)); // Reject with specific error
          }
        };

        // Safety timeout in case events don't fire
        timer = setTimeout(() => {
          console.warn(`SpeechSynthesis Timeout for "${text}"`);
          cleanup(new Error("TTS Timeout")); // Reject on timeout
        }, text.length * 150 + 4000); // Increased timeout buffer

        try {
          // Final cancellation check right before calling speak()
          if (!isSpeaking) {
            return cleanup(new Error("Cancelled"));
          }
          speechSynthesis.speak(utterance); // Start speaking
        } catch (e) {
          console.error("Error calling speechSynthesis.speak:", e);
          cleanup(e); // Reject if speak() call itself fails
        }
      });
    };

    const playHowjsayAudio = () => {
        // Promisified wrapper for playing Howjsay audio
        if (!levelStates[currentLevel] || !levelStates[currentLevel].wordIndices) { return Promise.reject(new Error("HJS: State not ready.")); }
        const state=levelStates[currentLevel]; const currentWordList=getLevelWords();
        if (state.currentIndex < 0 || state.currentIndex >= currentWordList.length) { return Promise.reject(new Error("HJS: Invalid index.")); }
        const wordData=currentWordList[state.currentIndex]; if (!wordData || !wordData.word) { return Promise.reject(new Error("HJS: Invalid word data.")); }

        // Sanitize word for URL: keep letters, hyphens, apostrophes
        const wordForUrl = wordData.word.toLowerCase().replace(/[^a-z\-']/g, '');
        if (!wordForUrl) { return Promise.reject(new Error("HJS: Invalid word after sanitization.")); }

        // Check cancellation flag before creating Audio object
        if (!isSpeaking) { return Promise.reject(new Error("Cancelled")); }

        const audio = new Audio(`https://howjsay.com/mp3/${wordForUrl}.mp3`);
        audio.volume = 0.7; // Set volume
        let resolved = false; // Flags to prevent multiple settlements
        let rejected = false;
        let timer = null; // Timeout handler

        // Cleanup function
        const cleanup = () => {
            clearTimeout(timer);
            // Remove event listeners to prevent memory leaks
            audio.oncanplaythrough = null;
            audio.onerror = null;
            audio.onended = null;
            audio.src = ""; // Release resource
            try { audio.load(); } catch (e) { /* Ignore cleanup errors */ }
        };

        return new Promise((resolve, reject) => {
            // Timeout for the entire process
            timer = setTimeout(() => {
                if (!resolved && !rejected) {
                    rejected = true;
                    console.warn(`Howjsay Timeout: "${wordForUrl}"`);
                    cleanup();
                    reject(new Error("Howjsay audio load/play timeout"));
                }
            }, 4000); // 4-second timeout

            // --- Event Handlers ---
            audio.oncanplaythrough = () => {
                if (resolved || rejected) return;
                // Check cancellation before playing
                if (!isSpeaking) { rejected = true; cleanup(); return reject(new Error("Cancelled")); }
                audio.play().catch(err => {
                    if (!resolved && !rejected) {
                        rejected = true;
                        console.error(`Howjsay Play Error: "${wordForUrl}"`, err);
                        cleanup();
                        reject(err); // Reject on play error
                    }
                });
            };

            audio.onerror = (e) => {
                if (!resolved && !rejected) {
                    rejected = true;
                    // Log less severely as this is common (word not found on howjsay)
                    console.warn(`Howjsay Load/Network Error: "${wordForUrl}" (May indicate word not found on Howjsay)`);
                    cleanup();
                    reject(new Error(`Howjsay audio failed to load`)); // Reject on load error
                }
            };

            audio.onended = () => {
                if (!resolved && !rejected) {
                    resolved = true;
                    cleanup();
                    resolve(); // Resolve on successful playback end
                }
            };

            // --- Load Initiation ---
            // Final cancellation check before load()
            if (!isSpeaking) { rejected = true; cleanup(); return reject(new Error("Cancelled")); }
            try {
                audio.load(); // Start loading the audio file
            } catch (loadError) {
                 if (!resolved && !rejected) { // Should be caught by onerror mostly, but added safety
                      rejected = true;
                      console.error(`Howjsay Initial Load Error: "${wordForUrl}"`, loadError);
                      cleanup();
                      reject(loadError);
                 }
            }
        });
    };
    // --- End of pronunciation helpers ---

    // --- Button State Management ---
    function disableButtons() {
      // Disables *only* the pronounce button during speech
      const pronounceButton = document.getElementById("pronounce");
      if (pronounceButton) pronounceButton.disabled = true;
    }

    function enableButtons() {
      // Enables the pronounce button (assumes other buttons remain enabled unless explicitly disabled elsewhere)
      // Check the isSpeaking flag again just to be safe - shouldn't enable if somehow still speaking
      if (!isSpeaking) {
          const pronounceButton = document.getElementById("pronounce");
          if (pronounceButton) pronounceButton.disabled = false;
      }
    }

    // --- LEVEL/REVIEW MODE MANAGEMENT ---
    function endReviewMode(forceComplete = false) {
      // Called when review mode finishes or when a level is completed without needing review
      if (!levelStates[currentLevel]) return;
      console.log("Ending Review / Completing Level:", currentLevel);

      levelStates[currentLevel].isReviewMode = false; // Ensure review mode flag is off

      // Increment completion count only if it wasn't forced completion *unless* there were no missed words anyway
      const hadMissedWords = levelStates[currentLevel].missedWords && levelStates[currentLevel].missedWords.length > 0;
      if (!forceComplete || !hadMissedWords) {
         levelCompletions[currentLevel] = (levelCompletions[currentLevel] || 0) + 1;
         console.log(`Level ${currentLevel} completions incremented to: ${levelCompletions[currentLevel]}`);
      } else {
         console.log(`Level ${currentLevel} completion count not incremented (forced complete or no missed words).`);
      }

      saveGameState(); // Save updated completions and state flags
      updateLevelSelect(); // Update dropdown display with new stars/trophies
      showLevelComplete(); // Show level complete animation (which handles moving to next level)
    }

    function showReviewMode() {
      // Transitions the UI to show the list of missed words for review
      if (!levelStates[currentLevel] || !levelStates[currentLevel].missedWords || levelStates[currentLevel].missedWords.length === 0) {
        console.log("showReviewMode called, but no missed words found. Completing level.");
        endReviewMode(true); // If no missed words, just complete the level
        return;
      }
      const state = levelStates[currentLevel];
      console.log("Showing Review Mode screen for level", currentLevel);

      // Hide main game content, show review section
      const mainContent = document.getElementById("mainContent");
      const reviewModeDiv = document.getElementById("review-mode");
      if (!mainContent || !reviewModeDiv) { console.error("Review mode UI elements missing!"); return; }

      mainContent.style.display = "none";
      reviewModeDiv.innerHTML = ''; // Clear previous review content
      reviewModeDiv.style.display = 'flex'; // Make review section visible

      // Create a container for the word buttons
      const wordButtonContainer = document.createElement("div");
      // Add word buttons for each missed word
      state.missedWords.forEach(wordObj => {
        const btn = document.createElement("button");
        btn.className = "word-button"; // Reuse style from wordlist.html
        btn.innerText = wordObj.word;
        // Make buttons clickable to show details? (Optional - not implemented here)
        // btn.onclick = () => { /* Maybe show definition popup? */ };
        wordButtonContainer.appendChild(btn);
      });
      reviewModeDiv.appendChild(wordButtonContainer);

      // Add the "Redo Missed Words" button
      const redoButton = document.createElement("button");
      redoButton.className = "redo-button"; // Reuse style
      redoButton.innerText = `Redo ${state.missedWords.length} Missed Word(s)`;
      redoButton.onclick = redoMissedWords; // Assign function to start review
      reviewModeDiv.appendChild(redoButton);

      // State is already saved before calling this usually, but save just in case? No, redo handles state setup.
    }

    function redoMissedWords() {
      // Starts the actual review session for the missed words
      console.log("Starting review session for level", currentLevel);
      const reviewModeDiv = document.getElementById("review-mode");
      const mainContent = document.getElementById("mainContent");

      // Hide review UI, show main game UI
      if (reviewModeDiv) reviewModeDiv.style.display = 'none';
      if (mainContent) mainContent.style.display = "block";

      // Validate state and missed words list
      if (!levelStates[currentLevel] || !levelStates[currentLevel].missedWords || levelStates[currentLevel].missedWords.length === 0) {
        console.warn("Redo called but no missed words found. Returning to normal mode/completing.");
        if (levelStates[currentLevel]) levelStates[currentLevel].isReviewMode = false; // Ensure flag is off
        showWord(); // Show the next word (or handle completion if level was already done)
        return;
      }

      const state = levelStates[currentLevel];
      state.isReviewMode = true; // Set review mode flag
      state.wordsCompleted = 0; // Reset completed count for review session
      state.failCount = 0; // Reset fail count for first review word
      isSpeaking = false; // Reset speaking flag
      speechSynthesis.cancel(); // Cancel any speech
      state.currentWord = ""; // Clear any input

      // Re-initialize word indices using the missedWords array
      initializeWordIndices(currentLevel); // This shuffles missed words and saves state

      // Check if indices were successfully initialized for review
      if (state.wordIndices && state.wordIndices.length > 0) {
        showWord(); // Display the first word of the review session
        // saveGameState(); // Already saved in initializeWordIndices
      } else {
        // Should have been caught earlier, but safety check
        console.log("Review initialization failed (no indices). Completing level.");
        endReviewMode(true); // Force completion if review setup fails
      }
    }

    // --- CELEBRATION & COMPLETION ANIMATIONS ---
    function showCelebration() {
      // Shows a short animation for a correct answer
      const celebrationDiv = document.getElementById("celebration");
      const mainContent = document.getElementById("mainContent");
      if (!celebrationDiv || !mainContent) return;

      mainContent.style.display = "none"; // Hide game content temporarily
      celebrationDiv.style.display = "block"; // Show celebration overlay
      // Ensure fresh start by clearing previous effects
      celebrationDiv.innerHTML = '<div class="celebration-text">🎉 Great Job! 🎉</div>';

      // Add random visual effects (stars, balloons, etc.)
      const effectTypes = ['star', 'balloon', 'firework', 'confetti'];
      const effectsToUse = [];
      // Randomly decide which effects to show (at least one)
      while(effectsToUse.length === 0){
          if (Math.random() > 0.5) effectsToUse.push('star');
          if (Math.random() > 0.5) effectsToUse.push('balloon');
          if (Math.random() > 0.5) effectsToUse.push('firework');
          if (Math.random() > 0.5) effectsToUse.push('confetti');
      }

      effectsToUse.forEach(effectType => {
        const count = effectType === 'star' ? 10 : effectType === 'balloon' ? 8 : effectType === 'firework' ? 15 : 20;
        for (let i = 0; i < count; i++) {
          const element = document.createElement("div");
          element.className = effectType; // Assign class for styling/animation
          element.style.left = `${Math.random() * 100}%`; // Random horizontal position
          element.style.top = `${Math.random() * 100}%`; // Random vertical position
          element.style.animationDelay = `${Math.random() * 0.5}s`; // Random start delay
          // Use random HSL color for variety
          element.style.background = `hsl(${Math.random() * 360}, 90%, 70%)`;
          celebrationDiv.appendChild(element);
        }
      });

      // Set timeout to hide celebration and move to the next word
      setTimeout(hideCelebration, 2000); // 2-second duration
    }

    function hideCelebration() {
      // Hides the celebration overlay and triggers the next word
      const celebrationDiv = document.getElementById("celebration");
      const mainContent = document.getElementById("mainContent");
      if (!celebrationDiv || !mainContent) return;

      celebrationDiv.style.display = "none"; // Hide overlay
      mainContent.style.display = "block"; // Show game content again
      // Clear effects for next time
      celebrationDiv.innerHTML = '<div class="celebration-text">🎉 Great Job! 🎉</div>';

      nextWord(); // Proceed to the next word
    }

    function showLevelComplete() {
      // Shows animation and message when a level (including review) is fully completed
      const levelCompleteDiv = document.getElementById("level-complete");
      const mainContent = document.getElementById("mainContent");
      if (!levelCompleteDiv || !mainContent) return;

      mainContent.style.display = "none"; // Hide game content
      levelCompleteDiv.style.display = "block"; // Show completion overlay
      // Reset content
      levelCompleteDiv.innerHTML = '<div class="level-complete-text"><span>🎉 Level Complete! 🎉</span><span></span></div>';

      playSound('levelComplete'); // Play cheering sound

      const messageSpan = levelCompleteDiv.querySelector(".level-complete-text span:last-child");
      if (!messageSpan) return;

      // --- Generate Completion Message ---
      const baseLevelNames = [ "Level 1-a", "Level 1-b", "Level 1-c", "Level 1-d", "Level 1-e", "Level 2-a", "Level 2-b", "Level 2-c", "Level 2-d", "Level 2-e", "Level 3-a", "Level 3-b", "Level 3-c", "Level 3-d", "Level 3-e", "Level 4", "Level 5", "Level 6", "Level 7", "Level 8", "Level 9" ];
      const completions = levelCompletions[currentLevel] || 0;
      const stars = completions % 5;
      const trophies = Math.floor(completions / 5);
      const nextLevelIndex = (currentLevel + 1) % baseLevelNames.length; // Wrap around for last level
      const nextLevelName = baseLevelNames[nextLevelIndex];

      let message = `You now have `;
      if (trophies > 0) message += `${trophies} 🏆 `;
      if (stars > 0) message += `${stars} ⭐`;
      if (trophies === 0 && stars === 0 && completions === 1) { message = "You earned your first ⭐!"; } // First star message
      else if (trophies === 0 && stars === 0) { message = "Level finished!"; } // Fallback if somehow count is 0
      message += `<br>Next up: ${nextLevelName}`; // Add next level info
      messageSpan.innerHTML = message; // Set the message text

      updateLevelSelect(); // Refresh dropdown display immediately

      // Add confetti/star effects
      for (let i = 0; i < 30; i++) {
        const element = document.createElement("div");
        element.style.left = `${Math.random() * 100}%`;
        element.style.top = `${Math.random() * 100}%`;
        element.style.animationDelay = `${Math.random() * 1.5}s`;
        const type = Math.floor(Math.random() * 2); // Stars or confetti
        const color = `hsl(${Math.random() * 360}, 90%, 70%)`;
        element.className = type === 0 ? "star" : "confetti";
        element.style.background = color;
        levelCompleteDiv.appendChild(element);
      }

      // Set timeout to hide overlay and proceed to the next level
      setTimeout(hideLevelComplete, 4500); // 4.5-second duration
    }

    function hideLevelComplete() {
      // Hides the level complete overlay and transitions to the next level
      const levelCompleteDiv = document.getElementById("level-complete");
      if (!levelCompleteDiv) return;

      levelCompleteDiv.style.display = "none"; // Hide overlay
      // Clear effects
      levelCompleteDiv.innerHTML = '<div class="level-complete-text"><span>🎉 Level Complete! 🎉</span><span></span></div>';

      // --- Transition to Next Level ---
      // Clear state for the *completed* level from memory and localStorage
      delete levelStates[currentLevel];
      localStorage.removeItem(`levelState_${currentLevel}`);

      // Determine next level index, wrapping around
      const levelSelect = document.getElementById("levelSelect");
      const numLevels = levelSelect ? levelSelect.options.length : 21; // Get number of levels from dropdown or default
      currentLevel = (currentLevel + 1) % numLevels; // Move to next level index, wrap around
      // localStorage.setItem('currentLevel', currentLevel); // Save new level (or handled by initialize)

      // Update dropdown selection
      if(levelSelect) levelSelect.value = currentLevel;

      initializeLevelState(currentLevel); // Initialize the new level
      showWord(); // Show the first word of the new level
    }

    // --- KEYBOARD INPUT ---
    function appendLetter(letter) {
      // Adds a letter to the current user input
      if (!levelStates[currentLevel]) return;
      // Optional: Add max length check if needed
      // if (levelStates[currentLevel].currentWord.length < MAX_WORD_LENGTH) {
           levelStates[currentLevel].currentWord += letter;
           updateDisplay();
      // }
    }

    function removeLetter() {
      // Removes the last letter from the current user input
      if (!levelStates[currentLevel] || levelStates[currentLevel].currentWord.length === 0) return;
      levelStates[currentLevel].currentWord = levelStates[currentLevel].currentWord.slice(0, -1); // Remove last char
      updateDisplay();
    }

    function clearWord() {
      // Clears the entire user input
      if (!levelStates[currentLevel]) return;
      levelStates[currentLevel].currentWord = "";
      updateDisplay();
    }

    function setupKeyboard() {
      // Dynamically creates the on-screen keyboard buttons
      /*console.log("Setting up keyboard...");*/
      const keyboardDiv = document.getElementById("keyboard");
      if (!keyboardDiv) return;
      keyboardDiv.innerHTML = ''; // Clear existing buttons if any
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      letters.forEach(letter => {
        const button = document.createElement("button");
        button.className = "key";
        button.innerText = letter;
        button.onclick = () => appendLetter(letter.toLowerCase()); // Add lowercase letter on click
        keyboardDiv.appendChild(button);
      });
      // Add Backspace button
      const backspaceButton = document.createElement("button");
      backspaceButton.id = "backspace";
      backspaceButton.className = "key";
      backspaceButton.innerText = "Back";
      backspaceButton.onclick = removeLetter;
      keyboardDiv.appendChild(backspaceButton);
      // Add Clear button
      const clearButton = document.createElement("button");
      clearButton.id = "clear";
      clearButton.className = "key";
      clearButton.innerText = "Clear";
      clearButton.onclick = clearWord;
      keyboardDiv.appendChild(clearButton);
      /*console.log("Keyboard setup complete.");*/
    }

    // --- POPUP & RESET LOGIC ---
    function showConfirmPopup() { // For Word List confirmation
      const popup = document.getElementById("confirmPopup");
      if (popup) popup.style.display = "block";
    }

    function hideConfirmPopup() {
      const popup = document.getElementById("confirmPopup");
      if (popup) popup.style.display = "none";
    }

    function goToWordList() {
      // Saves state before navigating to the word list page
      saveGameState(); // Ensure current level progress is saved
      window.location.href = 'wordlist.html'; // Navigate
    }

    function showResetConfirmPopup() { // Shows password prompt first
      const popup = document.getElementById("passwordPopup");
      if (!popup) return;
      currentPassword = ""; // Reset password input
      updatePasswordDisplay();
      const feedback = document.getElementById("passwordFeedback");
      if(feedback) feedback.innerText = ""; // Clear feedback
      popup.style.display = "block"; // Show password popup
    }

    function hidePasswordPopup() {
      const popup = document.getElementById("passwordPopup");
      if (!popup) return;
      popup.style.display = "none";
      currentPassword = ""; // Clear password on close
      updatePasswordDisplay();
       const feedback = document.getElementById("passwordFeedback");
      if(feedback) feedback.innerText = "";
    }

    function appendPasswordDigit(digit) {
      // Adds a digit to the password input (max 4 digits)
      if (currentPassword.length < 4) {
        currentPassword += digit;
        updatePasswordDisplay();
         const feedback = document.getElementById("passwordFeedback");
         if(feedback) feedback.innerText = ""; // Clear feedback on input
      }
    }

    function clearPassword() {
      // Clears the password input
      currentPassword = "";
      updatePasswordDisplay();
       const feedback = document.getElementById("passwordFeedback");
       if(feedback) feedback.innerText = "";
    }

    function updatePasswordDisplay() {
      // Updates the password display with dots
      const display = document.getElementById("passwordDisplay");
      if(display) display.innerText = "•".repeat(currentPassword.length);
    }

    function checkPassword() {
      // Checks the entered password and shows reset options if correct
      if (currentPassword === "5290") { // The password
        hidePasswordPopup(); // Hide password prompt
        const resetPopup = document.getElementById("resetConfirmPopup");
        if(resetPopup) resetPopup.style.display = "block"; // Show reset options
      } else {
        // Incorrect password handling
        const popup = document.getElementById("passwordPopup");
        const feedback = document.getElementById("passwordFeedback");
        if (feedback) feedback.innerText = "Wrong Password!";
        if (popup) popup.classList.add("shake"); // Shake animation
        currentPassword = ""; // Clear input
        updatePasswordDisplay();
        // Remove shake animation after it finishes
        setTimeout(() => { if (popup) popup.classList.remove("shake"); }, 500);
      }
    }

    function hideResetConfirmPopup() {
      // Hides the reset options popup
      const popup = document.getElementById("resetConfirmPopup");
      if(popup) popup.style.display = "none";
    }

    function resetAllProgress() {
      // Resets all game progress after confirmation
      if (!confirm("ARE YOU ABSOLUTELY SURE?\nThis will reset ALL levels, stars, and trophies.")) return;
      console.log("Resetting ALL game progress...");
      currentLevel = 0; // Reset to first level
      levelStates = {}; // Clear all saved level states
      levelCompletions = {}; // Clear all completion counts
      localStorage.clear(); // Clear everything from localStorage for this domain
      if(document.getElementById("levelSelect")) document.getElementById("levelSelect").value = 0; // Reset dropdown
      initializeLevelState(0); // Initialize level 0 state
      updateLevelSelect(); // Update dropdown display (remove stars/trophies)
      showWord(); // Show first word of level 0
      hideResetConfirmPopup(); // Hide the reset options popup
      alert("All progress has been reset.");
    }

    function resetCurrentLevel() {
      // Resets progress only for the currently selected level after confirmation
      if (!confirm(`Reset all progress for ${document.getElementById('levelSelect').options[currentLevel].text}?`)) {
          return;
      }
      console.log("Resetting current level:", currentLevel);
      // Remove state and completions for this level
      delete levelStates[currentLevel];
      delete levelCompletions[currentLevel];
      localStorage.removeItem(`levelState_${currentLevel}`); // Remove saved state from storage
      saveGameState(); // Save the removal of completions
      initializeLevelState(currentLevel); // Re-initialize the current level fresh
      updateLevelSelect(); // Update dropdown display for this level
      showWord(); // Show the first word
      hideResetConfirmPopup();
      alert("Current level progress reset.");
    }

    function addStarToLevel() { // Manual admin function
      if (!levelStates[currentLevel]) initializeLevelState(currentLevel); // Ensure state exists
      levelCompletions[currentLevel] = (levelCompletions[currentLevel] || 0) + 1;
      updateLevelSelect();
      saveGameState();
      hideResetConfirmPopup();
      console.log("Manual star added to level", currentLevel);
      alert(`Star added. Level ${currentLevel} now has ${levelCompletions[currentLevel]} completion(s).`);
    }

    function removeStarFromLevel() { // Manual admin function
      if (!levelCompletions[currentLevel] || levelCompletions[currentLevel] === 0) {
        alert("No stars/completions to remove from this level.");
        hideResetConfirmPopup();
        return;
      }
      levelCompletions[currentLevel] = Math.max(0, levelCompletions[currentLevel] - 1); // Decrement, min 0
      if (levelCompletions[currentLevel] === 0) {
         delete levelCompletions[currentLevel]; // Remove entry if count is zero
      }
      updateLevelSelect();
      saveGameState();
      hideResetConfirmPopup();
      console.log("Manual star removed from level", currentLevel);
       alert(`Star removed. Level ${currentLevel} now has ${levelCompletions[currentLevel] || 0} completion(s).`);
    }

    // --- EVENT LISTENERS & SHORTCUTS ---
    function togglePronounce() {
      // Toggles the full pronunciation setting
      fullPronounceEnabled = !fullPronounceEnabled;
      updatePronounceButton();
      saveGameState(); // Save the new preference
    }

    function setupKeyboardShortcuts() {
      // Sets up Ctrl+Shift+Z shortcut for auto-correct
      /*console.log("Setting up keyboard shortcuts...");*/
      document.addEventListener('keydown', (event) => {
        // Ignore shortcut if typing in an input/select/textarea
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.tagName === 'TEXTAREA')) {
            return;
        }
        // Check for Ctrl + Shift + Z (or z)
        if (event.ctrlKey && event.shiftKey && (event.key === 'Z' || event.key === 'z')) {
          event.preventDefault(); // Prevent default browser action (e.g., redo)
          console.log("Auto-correct shortcut triggered...");

          // Check conditions before applying
          if (isSpeaking) { console.log("Shortcut blocked: Currently speaking."); return; }
          if (!levelStates[currentLevel]) { console.log("Shortcut blocked: No level state."); return; }
          const state = levelStates[currentLevel];
          const currentWordList = getLevelWords();
          if (!state.wordIndices || state.indexPointer >= state.wordIndices.length) { console.log("Shortcut blocked: Invalid state or level complete."); return; }
          if (state.currentIndex < 0 || !currentWordList || state.currentIndex >= currentWordList.length) { console.log("Shortcut blocked: Invalid word index/data."); return; }

          const correctWord = currentWordList[state.currentIndex]?.word;
          if (!correctWord) { console.log("Shortcut blocked: Could not get correct word."); return; }

          // Apply auto-correct
          console.log("Applying auto-correct.");
          state.currentWord = correctWord.toLowerCase(); // Use lowercase
          updateDisplay();
          // Use setTimeout to allow display to update before checking
          setTimeout(checkSpelling, 50);
        }
      });
      /*console.log("Keyboard shortcuts ready.");*/
    }

    function setupMascotTap() {
        // Sets up triple-tap interaction on the mascot for auto-correct
        const mascotElement = document.getElementById("mascot");
        if (!mascotElement) return;

        // Using 'click' as primary for desktop, 'touchstart' might interfere less on mobile if needed later
        mascotElement.addEventListener('click', handleMascotInteraction);
        // Optionally add touchstart if click is unreliable on mobile, but handle preventDefault carefully
        // mascotElement.addEventListener('touchstart', (evt) => { evt.preventDefault(); handleMascotInteraction(); });
    }

    function handleMascotInteraction() {
        // Handles the logic for mascot taps (triple tap = auto-correct)
        tapCount++;
        clearTimeout(tapTimeout); // Reset timeout on each tap
        tapTimeout = setTimeout(() => {
            tapCount = 0; // Reset count if taps are too slow
        }, 500); // 500ms window for triple tap

        if (tapCount === 3) {
            console.log("Mascot triple-tap detected.");
            tapCount = 0; // Reset count
            clearTimeout(tapTimeout); // Clear timeout

            // --- Apply Auto-Correct Logic (same checks as shortcut) ---
             if (isSpeaking) { console.log("Mascot tap blocked: Currently speaking."); return; }
             if (!levelStates[currentLevel]) { console.log("Mascot tap blocked: No level state."); return; }
             const state = levelStates[currentLevel];
             const currentWordList = getLevelWords();
             if (!state.wordIndices || state.indexPointer >= state.wordIndices.length) { console.log("Mascot tap blocked: Invalid state or level complete."); return; }
             if (state.currentIndex < 0 || !currentWordList || state.currentIndex >= currentWordList.length) { console.log("Mascot tap blocked: Invalid word index/data."); return; }
             const correctWord = currentWordList[state.currentIndex]?.word;
             if (!correctWord) { console.log("Mascot tap blocked: Could not get correct word."); return; }

             console.log("Mascot applying auto-correct.");
             state.currentWord = correctWord.toLowerCase();
             updateDisplay();
             setTimeout(checkSpelling, 50); // Check after short delay
        }
    }

    function setupButtonClickListeners() {
        // Assigns JS functions to button onclick events (alternative to inline HTML onclick)
        // This is generally better practice but requires ensuring elements exist first.
        /*console.log("Setting up button listeners...");*/
        const pronounceBtn = document.getElementById("pronounce");
        const checkBtn = document.getElementById("checkAnswer");
        const showAnsBtn = document.getElementById("showAnswer");
        // ... other buttons ...

        if (pronounceBtn) pronounceBtn.onclick = pronounceWord;
        if (checkBtn) checkBtn.onclick = checkSpelling;
        if (showAnsBtn) showAnsBtn.onclick = showAnswer;
        // Add similar lines for other buttons if removing inline onclick attributes
        /*console.log("Button listeners setup complete.");*/
    }

    // --- INITIALIZATION ---
    function startGame() {
      // Main function to initialize and start the game on page load
      console.log("---- Starting Game ----");
      console.log("Spelling Bee Adventure by CC (Chih-Chun Chia)"); // <<< CONSOLE LOG ADDED

      // Initial setup if needed (keyboard, listeners)
      if (!document.getElementById('keyboard') || document.getElementById('keyboard').children.length === 0) {
        console.log("Performing first-time setup (Keyboard, Listeners)...");
        setupKeyboard();
        // setupButtonClickListeners(); // Use this if removing inline onclicks
        setupKeyboardShortcuts();
        setupMascotTap();
      } else {
        console.log("Skipping setup (already done or page reloaded).");
      }

      // Load saved state from localStorage
      loadGameState(); // This loads state and initializes if necessary

      // Ensure a word is displayed if state is valid
      if (levelStates[currentLevel] && levelStates[currentLevel].wordIndices && levelStates[currentLevel].wordIndices.length > 0) {
        showWord(); // Display the current or first word
      } else {
        // Handle case where loading/initialization failed to provide a word
        console.error("startGame: Failed to load or initialize state with words for level", currentLevel);
        alert("Error starting game. Could not load level data. Please refresh or select a different level.");
        // Optionally hide main content or show error message
        const mainContent = document.getElementById("mainContent");
        if(mainContent) mainContent.style.display = "none";
      }
      console.log("---- Game Started ----");
    }

    // --- DOMContentLoaded Listener (Entry Point) ---
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM loaded. Initializing game...");
      // Ensure the external words script is loaded before starting
      const wordsScript = document.querySelector('script[src="https://geniusjazz.github.io/spelling-bee/words_full.js"]');
      let gameInitialized = false; // Flag to prevent multiple initializations

      const initGame = () => {
          if (gameInitialized) return; // Prevent double init
          // Check if the keyboard exists and has keys - simple check if setup ran
          const keyboard = document.getElementById('keyboard');
          if (!keyboard || keyboard.children.length === 0) {
              startGame(); // Run main game start function
              gameInitialized = true;
          } else {
              // console.log("Initialization check: Game seems already started.");
          }
      };

      // Check if 'words' array is already available globally
      if (typeof words !== 'undefined' && Array.isArray(words) && words.length > 0) {
          console.log("Global 'words' array found immediately:", words.length);
          initGame();
      } else if (wordsScript) {
          // If script tag exists, wait for its onload event
          console.log("Waiting for words_full.js script to load...");
          wordsScript.onload = () => {
              if (typeof words !== 'undefined' && Array.isArray(words) && words.length > 0) {
                  console.log("words_full.js loaded successfully via onload:", words.length);
                  initGame();
              } else {
                  console.error("words_full.js onload fired, but 'words' array is still missing or invalid!");
                  alert("Error: Word list script loaded incorrectly. Please refresh.");
              }
          };
          // Handle script loading errors
          wordsScript.onerror = () => {
              console.error("Failed to load words_full.js script!");
              alert("Error: Could not load word list script. Please check your internet connection and refresh.");
              const mainContent = document.getElementById("mainContent");
              if(mainContent) mainContent.innerHTML = "<p style='color:red; font-weight:bold;'>Failed to load essential game data. Game cannot start.</p>";
          };
      } else {
          // Critical error: the script tag itself is missing
          console.error("Critical Error: Could not find the words_full.js script tag in the HTML!");
          alert("Critical Error: Word list script is missing from HTML. Game cannot start.");
           const mainContent = document.getElementById("mainContent");
           if(mainContent) mainContent.innerHTML = "<p style='color:red; font-weight:bold;'>Word list script missing. Game cannot start.</p>";
      }

      // Fallback check with timeout in case onload doesn't fire reliably
      setTimeout(() => {
          if (!gameInitialized && typeof words !== 'undefined' && Array.isArray(words) && words.length > 0) {
              console.log("Words array found after delay, attempting init if not already done.");
              initGame();
          } else if (!gameInitialized) {
               // Only show error if game hasn't started via other means
               console.warn("Still no 'words' array or game not initialized after timeout. Script might have failed silently or is slow.");
               // Avoid alert if possible, maybe show message in UI
               // alert("Word list loading timed out. Please refresh.");
               const progressText = document.getElementById("progress-text");
               if (progressText && progressText.innerText.includes("0/")) { // Check if game hasn't really started loading UI
                   progressText.innerHTML = "<span style='color:red;'>Word list failed to load.</span>";
               }
          }
      }, 3000); // 3-second timeout fallback

    }); // End DOMContentLoaded
  </script>

  <div class="watermark">Created by CC</div>

</body>
</html>
