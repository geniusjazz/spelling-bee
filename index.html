<!DOCTYPE html>
<html>
<head>
  <title>Spelling Bee Adventure</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      font-family: 'Comic Neue', cursive !important;
    }
    body {
      text-align: center;
      padding: 20px;
      background: url('https://subtlepatterns.com/patterns/honey_im_subtle.png') #fff9e6;
      margin: 0;
      color: #333;
      min-height: 100vh;
    }
    #header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      background: rgba(255, 235, 59, 0.7);
      border-bottom: 3px solid #f06292;
      margin-bottom: 20px;
    }
    #pronounce-toggle button {
      padding: 8px 15px;
      font-size: 16px;
      background: #4caf50;
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: background 0.3s;
    }
    #pronounce-toggle button.off {
      background: #f44336;
    }
    #wordListButton, #resetButton {
      width: 120px;
      background: #9c27b0;
      padding: 10px 15px;
      font-size: 16px;
      opacity: 0.7;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    #resetButton {
      background: #f44336;
    }
    #wordListButton:hover, #resetButton:hover {
      opacity: 1;
    }
    h1 {
      font-size: 48px;
      color: #e91e63;
      text-shadow: 2px 2px #ffeb3b;
      animation: bounce 2s infinite;
      margin-top: 20px;
    }
    #progress {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 20px 0;
      height: 40px;
    }
    .bee {
      width: 40px;
      height: 40px;
      background: url('https://img.icons8.com/ios-filled/50/ffeb3b/bee.png') no-repeat center; /* Fixed background URL */
      background-size: contain;
      margin-left: 10px;
    }
    #progress-bar-container {
      width: 90%;
      max-width: 400px;
      height: 20px;
      background: #ccc;
      border-radius: 10px;
      overflow: hidden;
      margin: 0 auto 10px auto;
    }
    #progress-bar {
      height: 100%;
      background: #4caf50;
      width: 0%;
      transition: width 0.5s ease;
    }
    #progress-text {
      font-size: 20px;
      color: #d81b60;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #part, #definition, #wordIndex {
      font-size: 24px;
      margin: 15px 0;
      color: #d81b60;
      background: rgba(255, 235, 59, 0.7);
      padding: 10px;
      border-radius: 15px;
      display: inline-block;
    }
    #wordDisplay {
      width: 90%;
      max-width: 450px;
      padding: 20px;
      font-size: 28px;
      margin: 20px auto;
      background: #ffffff;
      border: 4px dashed #2196f3;
      border-radius: 20px;
      min-height: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      transition: opacity 0.3s ease;
    }
    #wordDisplay.fade {
      opacity: 0;
    }
    button {
      padding: 20px 30px;
      font-size: 26px;
      margin: 15px auto;
      display: block;
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      touch-action: manipulation;
      transition: transform 0.2s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    button:hover:not(:disabled) {
      transform: scale(1.1);
    }
    button:active:not(:disabled) {
      transform: scale(0.95);
    }
    select {
      width: 90%;
      max-width: 300px;
      padding: 15px;
      font-size: 24px;
      margin: 15px auto;
      display: block;
      background: #ffeb3b;
      color: #d81b60;
      border: 3px solid #f06292;
      border-radius: 20px;
      cursor: pointer;
    }
    button:disabled, select:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
      box-shadow: none;
    }
    #pronounce {
      width: 90%;
      max-width: 350px;
      background: #4caf50;
    }
    #checkAnswer {
      width: 90%;
      max-width: 350px;
      background: #ff9800;
    }
    #showAnswer {
      width: 90%;
      max-width: 350px;
      background: #2196f3;
      display: none;
    }
    #keyboard {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 700px;
      margin: 20px auto;
    }
    .key {
      width: 60px;
      height: 60px;
      margin: 8px;
      font-size: 24px;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 3px solid #1976d2;
      border-radius: 15px;
      cursor: pointer;
      touch-action: manipulation;
      transition: transform 0.1s;
      box-shadow: 0 3px 6px rgba(0,0,0,0.2);
    }
    .key:hover:not(:disabled) {
      transform: scale(1.1);
    }
    .key:active:not(:disabled) {
      transform: scale(0.9);
    }
    .key:disabled {
      background: #cccccc;
      border-color: #aaaaaa;
      box-shadow: none;
    }
    #backspace {
      width: 90px;
      background: linear-gradient(135deg, #f44336, #ef5350);
      border-color: #d32f2f;
    }
    #clear {
      width: 90px;
      background: linear-gradient(135deg, #9c27b0, #ab47bc);
      border-color: #7b1fa2;
    }
    #feedback {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(1);
      padding: 40px;
      font-size: 36px;
      font-weight: bold;
      color: white;
      border-radius: 30px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
      z-index: 1000;
      animation: popIn 0.5s ease-out;
    }
    #feedback.wrong {
      background: #f44336;
      border: 5px solid #c62828;
    }
    #celebration, #level-complete {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      pointer-events: none;
    }
    .celebration-text, .level-complete-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #ffffff;
      text-shadow: 2px 2px 4px #000000;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      text-align: center; /* Added for better wrapping */
    }
    .level-complete-text span:first-child {
      font-size: 72px;
      color: #ffeb3b;
      animation: pulse 1s infinite;
    }
    .level-complete-text span:last-child {
      font-size: 36px;
      color: #ffffff;
    }
    .star {
      position: absolute;
      width: 40px;
      height: 40px;
      background: #ffeb3b;
      clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
      animation: spin 1.5s linear infinite;
    }
    .balloon {
      position: absolute;
      width: 30px;
      height: 40px;
      background: #f06292;
      border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
      animation: float 2s ease-in-out infinite;
    }
    .firework {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #2196f3;
      border-radius: 50%;
      animation: explode 1s ease-out forwards;
    }
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #ff9800;
      transform: rotate(45deg);
      animation: fall 2s linear forwards;
    }
    #mascot {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 100px;
      height: 100px;
      background: url('https://img.icons8.com/ios-filled/100/000000/bee.png') no-repeat center;
      background-size: contain;
      transition: transform 0.5s;
      cursor: pointer;
      z-index: 10;
    }
    #mascot.happy {
      transform: scale(1.2) rotate(10deg);
    }
    #mascot.sad {
      transform: scale(0.9) rotate(-10deg);
    }
    #confirmPopup, #resetConfirmPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 235, 59, 0.9);
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
      z-index: 1000;
      text-align: center;
      max-width: 80%;
      animation: popIn 0.5s ease-out;
    }
    #confirmPopup p, #resetConfirmPopup p {
      font-size: 28px;
      color: #d81b60;
      margin: 0 0 20px 0;
    }
    #confirmPopup button, #resetConfirmPopup button {
      width: 140px;
      padding: 10px;
      font-size: 18px;
      margin: 5px;
      display: inline-block;
    }
    #confirmYes {
      background: #4caf50;
    }
    #confirmNo {
      background: #f44336;
    }
    #resetAll {
      background: #f44336;
    }
    #resetLevel {
      background: #ff9800;
    }
    #addStar {
      background: #4caf50;
    }
    #removeStar {
      background: #2196f3;
    }
    #resetCancel {
      background: #9e9e9e;
    }
    #review-mode {
       max-width: 700px;
       margin: 20px auto;
       display: none; /* Start hidden */
       flex-direction: column; /* Stack word list and button */
       align-items: center; /* Center items */
       gap: 15px;
    }
     #review-mode > div { /* Style for word list container */
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
    }
    #passwordPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 235, 59, 0.9);
      padding: 15px;
      border-radius: 20px;
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
      z-index: 1000;
      text-align: center;
      max-width: 360px;
      width: 90%;
      animation: popIn 0.5s ease-out;
    }
    #passwordPopup p {
      font-size: 20px;
      color: #d81b60;
      margin: 0 0 6px 0;
    }
    #passwordPopup button {
      width: 80px;
      padding: 6px;
      font-size: 14px;
      margin: 5px;
      display: inline-block;
    }
    #passwordSubmit {
      background: #4caf50;
    }
    #passwordCancel {
      background: #f44336;
    }
    #keypad {
      display: grid;
      grid-template-columns: repeat(3, 35px);
      gap: 4px;
      max-width: 120px;
      margin: 0 auto 6px auto;
      justify-content: center;
    }
    #keypad .keypad-btn {
      width: 35px !important;
      height: 35px !important;
      font-size: 16px;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 2px solid #1976d2;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.1s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      box-sizing: border-box;
      padding: 0;
      margin: 0;
      line-height: 35px;
      text-align: center;
    }
    #keypad .keypad-btn:hover {
      transform: scale(1.1);
    }
    #keypad .keypad-btn:active {
      transform: scale(0.9);
    }
    #keypad #keypadClear {
      background: linear-gradient(135deg, #f44336, #ef5350);
      border-color: #d32f2f;
      grid-column: 2 / 3;
    }
    #passwordDisplay {
      font-size: 20px;
      color: #d81b60;
      margin: 5px 0;
      min-height: 20px;
    }
    #passwordFeedback {
      font-size: 12px;
      color: #f44336;
      margin: 5px 0;
      min-height: 14px;
    }
    @keyframes shake {
      0% { transform: translate(-50%, -50%) translateX(0); }
      25% { transform: translate(-50%, -50%) translateX(-5px); }
      50% { transform: translate(-50%, -50%) translateX(5px); }
      75% { transform: translate(-50%, -50%) translateX(-5px); }
      100% { transform: translate(-50%, -50%) translateX(0); }
    }
    .shake {
      animation: shake 0.5s ease-in-out;
    }
    @media (max-width: 768px) {
      #passwordPopup {
        max-width: 320px;
        padding: 10px;
      }
      #passwordPopup p {
        font-size: 18px;
      }
      #passwordPopup button {
        width: 70px;
        font-size: 12px;
        padding: 5px;
      }
      #keypad {
        grid-template-columns: repeat(3, 30px);
        max-width: 105px;
        gap: 3px;
      }
      #keypad .keypad-btn {
        width: 30px !important;
        height: 30px !important;
        font-size: 14px;
        border-radius: 6px;
        line-height: 30px;
      }
      #passwordDisplay {
        font-size: 18px;
        margin: 4px 0;
      }
      #passwordFeedback {
        font-size: 10px;
        margin: 4px 0;
      }
    }
    .word-button {
      padding: 10px 20px;
      font-size: 28px;
      font-weight: bold;
      background: linear-gradient(135deg, #2196f3, #42a5f5);
      color: white;
      border: 4px solid #1976d2;
      border-radius: 15px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .word-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    .word-button:active {
      transform: scale(0.95);
    }
    .redo-button {
      padding: 15px 30px;
      font-size: 26px;
      background: linear-gradient(135deg, #4caf50, #66bb6a);
      color: white;
      border: 4px solid #388e3c;
      border-radius: 25px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      margin-top: 20px;
    }
    .redo-button:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    .redo-button:active {
      transform: scale(0.95);
    }
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-15px); }
      60% { transform: translateY(-10px); }
    }
    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
      80% { transform: translate(-50%, -50%) scale(1.15); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    @keyframes spin {
      0% { transform: rotate(0deg) scale(1); }
      50% { transform: rotate(180deg) scale(1.2); }
      100% { transform: rotate(360deg) scale(1); }
    }
    @keyframes float {
      0% { transform: translateY(0); }
      50% { transform: translateY(-20px); }
      100% { transform: translateY(0); }
    }
    @keyframes explode {
      0% { transform: scale(1); opacity: 1; }
      100% { transform: scale(10); opacity: 0; }
    }
    @keyframes fall {
      0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    @media (max-width: 768px) {
      h1 { font-size: 36px; margin-top: 20px; }
      #part, #definition, #wordIndex { font-size: 20px; padding: 8px; }
      #wordDisplay { font-size: 24px; padding: 15px; }
      button, select { font-size: 22px; padding: 15px 25px; }
      .key { width: 50px; height: 50px; font-size: 20px; margin: 5px; }
      #backspace, #clear { width: 70px; }
      #feedback { font-size: 28px; padding: 30px; }
      .celebration-text { font-size: 36px; }
      .level-complete-text span:first-child { font-size: 48px; }
      .level-complete-text span:last-child { font-size: 24px; }
      .star { width: 30px; height: 30px; }
      .balloon { width: 20px; height: 30px; }
      .firework, .confetti { width: 8px; height: 8px; }
      #mascot { width: 60px; height: 60px; bottom: 10px; right: 10px; }
      .bee { width: 30px; height: 30px; }
      #progress-text { font-size: 18px; }
      #header { padding: 10px; }
      #pronounce-toggle button {
        width: 90px;
        padding: 6px 10px;
        font-size: 12px;
      }
      #wordListButton, #resetButton {
        width: 80px;
        padding: 6px 10px;
        font-size: 12px;
      }
      #confirmPopup p, #resetConfirmPopup p { font-size: 24px; }
      #confirmPopup button, #resetConfirmPopup button { width: 100px; font-size: 18px; padding: 12px; }
      .word-button { font-size: 22px; padding: 8px 15px; }
      .redo-button { font-size: 20px; padding: 12px 25px; }
    }
  </style>
</head>
<body>
  <div id="header">
    <div id="pronounce-toggle">
      <button id="fullPronounce" onclick="togglePronounce()">Full Pronunciation: On</button>
    </div>
    <button id="wordListButton" onclick="showConfirmPopup()">Word List</button>
    <button id="resetButton" onclick="showResetConfirmPopup()">Reset Progress</button>
  </div>
  <h1>Spelling Bee Adventure</h1>
  <div id="mainContent">
    <select id="levelSelect" onchange="changeLevel()">
      <option value="0">Level 1-a</option>
      <option value="1">Level 1-b</option>
      <option value="2">Level 1-c</option>
      <option value="3">Level 1-d</option>
      <option value="4">Level 1-e</option>
      <option value="5">Level 2-a</option>
      <option value="6">Level 2-b</option>
      <option value="7">Level 2-c</option>
      <option value="8">Level 2-d</option>
      <option value="9">Level 2-e</option>
      <option value="10">Level 3-a</option>
      <option value="11">Level 3-b</option>
      <option value="12">Level 3-c</option>
      <option value="13">Level 3-d</option>
      <option value="14">Level 3-e</option>
      <option value="15">Level 4</option>
      <option value="16">Level 5</option>
      <option value="17">Level 6</option>
      <option value="18">Level 7</option>
      <option value="19">Level 8</option>
      <option value="20">Level 9</option>
    </select>
    <div id="progress"></div>
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>
    <div id="progress-text">Words Completed: 0/10 <div class="bee"></div></div>
    <div id="part"></div>
    <div id="definition"></div>
    <div id="wordIndex"></div>
    <button id="pronounce" onclick="pronounceWord()">Pronounce</button>
    <div id="wordDisplay"></div>
    <div id="keyboard"></div>
    <button id="checkAnswer" onclick="checkSpelling()">Check Answer</button>
    <button id="showAnswer" onclick="showAnswer()">Show Answer</button>
  </div>
  <div id="feedback" onclick="hideFeedback()"></div>
  <div id="celebration"><div class="celebration-text">ðŸŽ‰ Great Job! ðŸŽ‰</div></div>
  <div id="level-complete"><div class="level-complete-text"><span>ðŸŽ‰ Level Complete! ðŸŽ‰</span><span></span></div></div>
  <div id="mascot"></div>
  <div id="confirmPopup">
    <p>Want to peek at the word list?</p>
    <button id="confirmYes" onclick="goToWordList()">Yes</button>
    <button id="confirmNo" onclick="hideConfirmPopup()">No</button>
  </div>
  <div id="passwordPopup">
    <p>Enter Password to Reset:</p>
    <div id="passwordDisplay"></div>
    <div id="passwordFeedback"></div>
    <div id="keypad">
      <button class="keypad-btn" onclick="appendPasswordDigit('1')">1</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('2')">2</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('3')">3</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('4')">4</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('5')">5</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('6')">6</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('7')">7</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('8')">8</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('9')">9</button>
      <button class="keypad-btn" onclick="appendPasswordDigit('0')">0</button>
      <button id="keypadClear" class="keypad-btn" onclick="clearPassword()">Clear</button> </div>
    <button id="passwordSubmit" onclick="checkPassword()">Submit</button>
    <button id="passwordCancel" onclick="hidePasswordPopup()">Cancel</button>
  </div>
  <div id="resetConfirmPopup">
    <p>Reset Options:</p>
    <button id="resetAll" onclick="resetAllProgress()">Reset All Progress</button>
    <button id="resetLevel" onclick="resetCurrentLevel()">Reset Current Level</button>
    <button id="addStar" onclick="addStarToLevel()">Add Star</button>
    <button id="removeStar" onclick="removeStarFromLevel()">Remove Star</button>
    <button id="resetCancel" onclick="hideResetConfirmPopup()">Cancel</button>
  </div>
  <div id="review-mode"> </div>

  <script src="https://geniusjazz.github.io/spelling-bee/words_full.js"></script>

  <script>
    let currentLevel = 0;
    let levelStates = {}; // Stores state for each level { levelIndex: stateObject }
    let levelCompletions = {}; // Stores completion count { levelIndex: count }
    let lastPronouncedIndex = -1; // Tracks the index of the last word fully pronounced
    let isSpeaking = false; // Flag to prevent overlapping speech/audio
    let tapCount = 0; // Counter for mascot taps
    let tapTimeout; // Timeout for mascot taps
    let fullPronounceEnabled = true; // Toggle for detailed pronunciation
    let currentPassword = ""; // For reset password entry

    // --- UTILITY FUNCTIONS ---

    // Fisher-Yates shuffle
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Sound effects playback
    function playSound(type) {
      const audio = new Audio();
      if (type === 'correct') audio.src = 'https://www.soundjay.com/buttons/sounds/button-3.mp3';
      else if (type === 'wrong') audio.src = 'https://www.soundjay.com/buttons/sounds/beep-03.mp3';
      else if (type === 'levelComplete') audio.src = 'https://www.soundjay.com/human/sounds/cheering-01.mp3';
      audio.volume = 0.7;
      audio.play().catch((err) => console.warn(`Sound ${type} failed to play:`, err)); // Added warning on failure
    }

    // --- STATE MANAGEMENT ---

    function saveGameState() {
       // Prevent saving if levelStates doesn't have the current level initialized
      if (!levelStates[currentLevel]) {
         console.warn("Attempted to save game state for uninitialized level:", currentLevel);
         return;
      }
      // Only save necessary parts of the state
      const currentStateToSave = {
        failCount: levelStates[currentLevel].failCount,
        wordsCompleted: levelStates[currentLevel].wordsCompleted,
        wordIndices: levelStates[currentLevel].wordIndices,
        indexPointer: levelStates[currentLevel].indexPointer,
        isReviewMode: levelStates[currentLevel].isReviewMode,
        missedWords: levelStates[currentLevel].missedWords,
        // No need to save currentIndex and currentWord in localStorage typically
      };
      try {
         localStorage.setItem('currentLevel', currentLevel);
         localStorage.setItem(`levelState_${currentLevel}`, JSON.stringify(currentStateToSave)); // Save individual level
         localStorage.setItem('levelCompletions', JSON.stringify(levelCompletions));
         localStorage.setItem('fullPronounceEnabled', fullPronounceEnabled);
         console.log("Game state saved for level:", currentLevel, currentStateToSave);
      } catch (e) {
         console.error("Error saving game state to localStorage:", e);
         // Consider notifying the user that progress might not be saved
      }
    }

    function loadGameState() {
      console.log("Loading game state...");
      try {
        currentLevel = parseInt(localStorage.getItem('currentLevel')) || 0;
        levelCompletions = JSON.parse(localStorage.getItem('levelCompletions')) || {};
        fullPronounceEnabled = localStorage.getItem('fullPronounceEnabled') !== 'false';

        // Load states for *all* levels found in storage
        levelStates = {}; // Reset local cache first
        for (let i = 0; i < 21; i++) { // Assuming max level index 20 (Level 9)
            const storedState = localStorage.getItem(`levelState_${i}`);
            if (storedState) {
                levelStates[i] = JSON.parse(storedState);
                 // Add back transient properties needed at runtime
                 levelStates[i].currentIndex = levelStates[i].wordIndices ? levelStates[i].wordIndices[levelStates[i].indexPointer] : 0;
                 levelStates[i].currentWord = ""; // Input word resets on load
                console.log("Loaded state for level", i);
            }
        }

        document.getElementById("levelSelect").value = currentLevel; // Set dropdown
        updatePronounceButton(); // Update UI button
        updateLevelSelect(); // Update dropdown text with stars/trophies

        // Ensure current level state exists, initialize if not
        if (!levelStates[currentLevel]) {
            console.log(`State for current level ${currentLevel} not found in localStorage, initializing.`);
            initializeLevelState(currentLevel);
        } else {
            console.log("Loaded state for current level:", currentLevel, levelStates[currentLevel]);
        }

      } catch (e) {
          console.error("Error loading game state from localStorage:", e);
          // Fallback to default state if loading fails
          currentLevel = 0;
          levelStates = {};
          levelCompletions = {};
          fullPronounceEnabled = true;
          initializeLevelState(currentLevel); // Initialize default level 0
          updateLevelSelect(); // Update visuals
      }
    }

    function initializeLevelState(level) {
      console.log(`Initializing level ${level} state...`);
      const isReview = levelStates[level]?.isReviewMode || false; // Preserve review mode if re-initializing mid-review?
      const missed = levelStates[level]?.missedWords || []; // Preserve missed words

      levelStates[level] = {
        failCount: 0,
        wordsCompleted: 0,
        wordIndices: [],
        indexPointer: 0,
        isReviewMode: isReview, // Keep review mode status if it was set
        missedWords: isReview ? missed : [], // Keep missed words only if in review mode
        currentIndex: 0, // Will be set by initializeWordIndices/showWord
        currentWord: "" // User input always starts empty
      };
      initializeWordIndices(level); // Populate wordIndices and set indexPointer
      // Note: saveGameState() is called within initializeWordIndices if needed
    }

     function initializeWordIndices(level) {
        if (!levelStates[level]) {
            console.error("Cannot initialize indices for non-existent level state:", level);
            return;
        }
        const state = levelStates[level];
        const levelWordData = getLevelWords(); // Get the actual word objects for the level

        // Determine the source of indices: missed words or full level list
        let sourceArray;
        if (state.isReviewMode) {
            sourceArray = state.missedWords;
            if (!sourceArray || sourceArray.length === 0) {
                 console.warn(`Attempting review mode for level ${level} with no missed words. Completing level.`);
                 endReviewMode(true); // Pass flag to indicate completion without review
                 return; // Stop initialization
            }
            state.wordIndices = shuffle(Array.from({ length: sourceArray.length }, (_, i) => i)); // Indices refer to missedWords array
            console.log(`Initialized indices for level ${level} (review mode):`, state.wordIndices);
        } else {
            sourceArray = levelWordData;
            if (!sourceArray || sourceArray.length === 0) {
                 console.error(`No words found for level ${level} in normal mode.`);
                 // Handle this error - maybe show a message? For now, return.
                 return;
            }
            state.wordIndices = shuffle(Array.from({ length: sourceArray.length }, (_, i) => i)); // Indices refer to the main words slice
             console.log(`Initialized indices for level ${level} (normal mode):`, state.wordIndices);
        }

        state.indexPointer = 0; // Start from the beginning of the shuffled list
        state.currentWord = ""; // Clear any typed input
        state.failCount = 0; // Reset fails for the new/reset level
        lastPronouncedIndex = -1; // Reset pronunciation tracking

        updateProgress(); // Update UI display
        saveGameState(); // Save the newly initialized state
    }

    // --- UI UPDATES ---

    function updatePronounceButton() {
      const btn = document.getElementById("fullPronounce");
      btn.innerText = `Full Pronunciation: ${fullPronounceEnabled ? 'On' : 'Off'}`;
      btn.className = fullPronounceEnabled ? '' : 'off';
    }

     function updateLevelSelect() {
        const select = document.getElementById("levelSelect");
        // Use fixed base names, assuming the number of options matches
        const baseOptions = Array.from(select.options).map(opt => {
            // Attempt to get the base name before stars/trophies were added
            // This assumes the base name doesn't contain these emojis
            return opt.text.split(' ')[0] + (opt.text.includes('-') ? '-' + opt.text.split(' ')[0].split('-')[1] : '');
        });

        if(baseOptions.length < 21) { // Simple check
            console.warn("Mismatch between expected levels and dropdown options.");
            // Fallback or fixed names if needed
        }

        for (let i = 0; i < select.options.length; i++) {
            const level = parseInt(select.options[i].value);
            // Ensure base name exists before appending, prevent duplication
            let currentText = select.options[i].text.replace(/ [ðŸ†â­]+/g, ''); // Remove existing emojis first

            const completions = levelCompletions[level] || 0;
            const stars = completions % 5;
            const trophies = Math.floor(completions / 5);
            let suffix = '';
            if (trophies > 0) suffix += ' ðŸ†'.repeat(trophies);
            if (stars > 0) suffix += ' â­'.repeat(stars);

            select.options[i].text = currentText + suffix;
        }
    }

    function updateDisplay() {
      const wordDisplay = document.getElementById("wordDisplay");
      if (!levelStates[currentLevel]) return; // Prevent errors if state is missing

      wordDisplay.classList.add("fade");
      setTimeout(() => {
        wordDisplay.innerText = levelStates[currentLevel]?.currentWord || ""; // Handle potential undefined state
        wordDisplay.classList.remove("fade");
        // console.log("Display updated to:", levelStates[currentLevel]?.currentWord); // Reduce console noise
      }, 150);
    }

    function updateProgress() {
       if (!levelStates[currentLevel]) return; // Guard against missing state

      const state = levelStates[currentLevel];
      const progressBar = document.getElementById("progress-bar");
      const progressText = document.getElementById("progress-text");

      // Determine total words based on mode and level
      let totalWords = 0;
      if(state.isReviewMode) {
          totalWords = state.missedWords?.length || 0;
      } else {
          totalWords = (currentLevel < 15 ? 10 : 50);
      }

      if (totalWords > 0) {
        const percentComplete = (state.wordsCompleted / totalWords) * 100;
        progressBar.style.width = `${percentComplete}%`;
      } else {
        progressBar.style.width = '0%'; // No progress if no words
      }

      progressText.innerHTML = `Words Completed: ${state.wordsCompleted}/${totalWords} <div class="bee"></div>`;
    }

    function showFeedback(message, isCorrect) {
      const feedback = document.getElementById("feedback");
      const mascot = document.getElementById("mascot");
      feedback.innerText = message;
      feedback.className = isCorrect ? "" : "wrong"; // Use class for styling wrong feedback
      feedback.style.display = message ? "block" : "none"; // Show only if there's a message
      mascot.className = isCorrect ? "happy" : "sad";

      // Hide incorrect feedback automatically
      if (!isCorrect && message) {
        setTimeout(() => {
          if (feedback.innerText === message) { // Only hide if the message hasn't changed
             feedback.style.display = "none";
             mascot.className = ""; // Reset mascot only when feedback hides
          }
        }, 1500);
      } else if (isCorrect) {
          // Instantly reset mascot for correct answers (or after celebration)
          mascot.className = "happy"; // Ensure it's happy
          // Resetting after celebration might be better UX
      }
    }

    function hideFeedback() {
      document.getElementById("feedback").style.display = "none";
      document.getElementById("mascot").className = ""; // Reset mascot
    }

    // --- GAME LOGIC ---

    function getLevelWords() {
        const state = levelStates[currentLevel];
        if (!state) {
            console.error("getLevelWords called with no state for level:", currentLevel);
            return []; // Return empty array if state is missing
        }

        if (state.isReviewMode) {
            // Return the actual word objects stored in missedWords
            return state.missedWords || [];
        }

        // Calculate start index for normal mode
        let start;
        if (currentLevel < 5) start = currentLevel * 10;         // Levels 0-4 (1a-1e)
        else if (currentLevel < 10) start = 50 + (currentLevel - 5) * 10;  // Levels 5-9 (2a-2e)
        else if (currentLevel < 15) start = 100 + (currentLevel - 10) * 10; // Levels 10-14 (3a-3e)
        else start = 150 + (currentLevel - 15) * 50; // Levels 15+ (4-9)

        const count = currentLevel < 15 ? 10 : 50;

        // Ensure 'words' array is available and has enough words
        if (typeof words === 'undefined' || !Array.isArray(words)) {
            console.error("'words' array is not available!");
            // Maybe trigger reload or show error message
            return [];
        }
        if (start + count > words.length) {
            console.warn(`Level ${currentLevel} requires words up to index ${start + count -1}, but words array only has ${words.length} elements.`);
            // Return only available words, might lead to shorter levels
            return words.slice(start);
        }

        const levelWords = words.slice(start, start + count);
        // console.log(`Level ${currentLevel} words (start: ${start}, count: ${count}):`, levelWords.length);
        return levelWords;
    }

    function showWord() {
      console.log("---- showWord ----");
      // Ensure state exists for the current level
      if (!levelStates[currentLevel]) {
          console.error(`State missing for level ${currentLevel} in showWord. Initializing.`);
          initializeLevelState(currentLevel);
          // If initialization failed (e.g., no words), we might need to stop here or show an error
          if (!levelStates[currentLevel]) {
               alert("Failed to initialize level state. Please refresh.");
               return;
          }
      }
      const state = levelStates[currentLevel];

      // Get the words for the current level/mode
      const levelWordData = getLevelWords(); // Changed name for clarity

      // Check if words are available for the level
      if (!levelWordData || levelWordData.length === 0) {
          console.error("No words available for current level/mode:", currentLevel, state.isReviewMode);
          // Potentially show an error message to the user, or auto-advance/complete level
          if (state.isReviewMode) {
                console.log("No review words left, ending review mode.");
                endReviewMode(true); // Complete level if review list is empty
          } else {
                alert(`Error: No words found for Level ${document.getElementById('levelSelect').selectedOptions[0].text}. Please check the word list or select another level.`);
          }
          return; // Stop execution for this word
      }

      // Check if wordIndices array needs initialization or is finished
      if (!state.wordIndices || state.wordIndices.length === 0 || state.indexPointer >= state.wordIndices.length) {
           // This case should ideally be handled by nextWord() advancing to review/completion
           // But as a fallback, reinitialize indices if they are missing/empty
          console.warn("Word indices issue in showWord. Reinitializing indices for level:", currentLevel);
          initializeWordIndices(currentLevel); // This will reset pointer and shuffle
           // Check again if indices were successfully initialized
          if (!state.wordIndices || state.wordIndices.length === 0) {
               console.error("Failed to initialize word indices. Cannot show word.");
               return;
          }
      }

      // Get the specific index for the current word from the shuffled list
      const wordIndexInSourceArray = state.wordIndices[state.indexPointer];
      // Get the actual word object using that index from the correct source (levelWordData)
      const w = levelWordData[wordIndexInSourceArray];

      // Validate the word object
      if (!w || !w.word || !w.part || !w.definition || typeof w.no === 'undefined') {
           console.error("Invalid word data retrieved:", { wordIndexInSourceArray, retrievedWord: w, levelWordDataLength: levelWordData.length });
           // Maybe try advancing to the next word or reinitializing
           alert("Error retrieving word data. Please try advancing the word or changing levels.");
           // Attempt to recover by advancing index? Risky.
           // state.indexPointer++; // Be careful with infinite loops
           // showWord(); return;
           return;
      }

      // Update the stored currentIndex (mainly for pronunciation reference)
      state.currentIndex = wordIndexInSourceArray; // This index refers to position within levelWordData

      console.log(`Displaying word: IndexPointer=${state.indexPointer}, WordIndexInSource=${wordIndexInSourceArray}, Word=${w.word}`);

      // Update UI elements
      document.getElementById("part").innerText = "Part of Speech: " + w.part;
      document.getElementById("definition").innerText = "Definition: " + w.definition;
      document.getElementById("wordIndex").innerText = "Word #" + w.no; // Use the original number
      state.currentWord = ""; // Clear previous input
      updateDisplay(); // Update the spelling input area (should be empty now)

      // Reset fail count for the new word display
      // state.failCount = 0; // Moved failCount reset to nextWord/initialize

      // Show/hide 'Show Answer' button based on fail count
      document.getElementById("showAnswer").style.display = state.failCount >= 3 ? "block" : "none";
      document.getElementById("showAnswer").disabled = state.failCount < 3;

      // Ensure main content is visible and mascot is reset
      document.getElementById("mainContent").style.display = "block";
      const reviewDiv = document.getElementById("review-mode");
      if (reviewDiv) reviewDiv.style.display = "none"; // Hide review mode if active
      document.getElementById("mascot").className = "";

      updateProgress(); // Update progress bar/text
      enableButtons(); // Make sure buttons are clickable
    }

    function changeLevel() {
      const newLevel = parseInt(document.getElementById("levelSelect").value);
      console.log("Changing level to:", newLevel);
      // No need to save state here, as loading/initialization handles the switch
      currentLevel = newLevel;
      localStorage.setItem('currentLevel', currentLevel); // Save selection immediately

      // Ensure state is loaded or initialized for the new level
      if (!levelStates[currentLevel]) {
        initializeLevelState(currentLevel);
      } else {
         // Reset transient parts of existing state when switching levels
         levelStates[currentLevel].currentWord = "";
         // Maybe reset indexPointer if user should start level over? Optional.
         // levelStates[currentLevel].indexPointer = 0;
         // levelStates[currentLevel].currentIndex = levelStates[currentLevel].wordIndices[0];
         console.log("Loaded existing state for level", newLevel);
      }

      isSpeaking = false; // Reset speaking flag
      speechSynthesis.cancel(); // Cancel any ongoing speech

      showWord(); // Display the first word of the new level
      // saveGameState(); // Save the state *after* initializing/loading and showing word
    }

    function checkSpelling() {
      if (isSpeaking) {
        speechSynthesis.cancel();
        isSpeaking = false;
        // Optionally re-enable buttons immediately if check is pressed during speech
        enableButtons();
      }

      if (!levelStates[currentLevel]) {
         console.error("Cannot check spelling, level state is missing.");
         return;
      }
      const state = levelStates[currentLevel];
      const levelWordData = getLevelWords(); // Get words for current context

      // Ensure currentIndex is valid for the current levelWordData
      if (state.currentIndex < 0 || state.currentIndex >= levelWordData.length) {
          console.error("Invalid currentIndex in checkSpelling:", state.currentIndex);
          showWord(); // Try to recover by showing the word again
          return;
      }

      const correctWord = levelWordData[state.currentIndex].word;
      const userInput = state.currentWord.trim().toLowerCase();

      console.log("Checking spelling:", { userInput, correctWord });

      if (userInput === correctWord) {
        state.wordsCompleted++;
        playSound('correct');
        showFeedback("", true); // No message needed for correct, just mascot
        showCelebration(); // This function handles hiding content and calling nextWord via hideCelebration
        // No need to call nextWord directly here
        saveGameState(); // Save progress after correct answer
      } else {
        state.failCount++;
        // Add to missed words only on the *first* fail in *normal* mode
        if (state.failCount === 1 && !state.isReviewMode) {
           // Ensure missedWords array exists
          if (!state.missedWords) state.missedWords = [];
          // Add the full word object
          state.missedWords.push(levelWordData[state.currentIndex]);
           console.log("Added to missed words:", levelWordData[state.currentIndex].word);
        }

        playSound('wrong');
        showFeedback("âŒ Oops! Try Again! âŒ", false);

        if (state.failCount >= 3) {
          document.getElementById("showAnswer").style.display = "block";
          document.getElementById("showAnswer").disabled = false;
        }
        state.currentWord = ""; // Clear input field on wrong answer
        updateDisplay();
        saveGameState(); // Save state after incorrect attempt (fail count, missed words)
      }
    }

    function showAnswer() {
      if (isSpeaking) { // Don't interrupt speech to show answer
           console.log("Cannot show answer while speaking.");
           return;
      }
      if (!levelStates[currentLevel]) return;

      const state = levelStates[currentLevel];
      const levelWordData = getLevelWords();
      if (state.currentIndex < 0 || state.currentIndex >= levelWordData.length) {
          console.error("Invalid currentIndex in showAnswer:", state.currentIndex);
          return;
      }
      const correctWord = levelWordData[state.currentIndex].word;
      showFeedback(`Answer: ${correctWord}`, false); // Show answer using the feedback mechanism
    }

    function nextWord() {
      console.log("---- nextWord ----");
       if (!levelStates[currentLevel]) {
           console.error("Cannot go to next word, level state is missing.");
           return;
       }
      const state = levelStates[currentLevel];
      state.indexPointer++; // Advance the pointer to the next shuffled index

      // Check if we've finished all words in the current list (normal or review)
      if (state.indexPointer >= state.wordIndices.length) {
        console.log("Finished words in current list.");
        if (state.isReviewMode) {
          console.log("Ending review mode.");
          endReviewMode(); // Finished review, complete the level
        } else if (state.missedWords && state.missedWords.length > 0) {
          console.log("Starting review mode.");
          showReviewMode(); // Finished normal mode, start review if needed
        } else {
           console.log("No missed words, completing level directly.");
           endReviewMode(true); // Finished normal mode, no missed words, complete level
        }
        return; // Stop further execution as we transition mode or level
      }

      // If more words remain in the current list:
      state.failCount = 0; // Reset fail count for the new word
      isSpeaking = false; // Reset speaking flag
      speechSynthesis.cancel(); // Cancel any leftover speech
      state.currentWord = ""; // Clear input
      lastPronouncedIndex = -1; // Reset for pronunciation logic

      showWord(); // Display the next word
      saveGameState(); // Save state after successfully moving to the next word
    }

    // --- PRONUNCIATION ---

    function pronounceWord() {
      if (isSpeaking) {
          console.log("Already speaking, pronounce request ignored.");
          // Optional: Allow interrupting current speech?
          // speechSynthesis.cancel();
          // isSpeaking = false; // Then continue below? Might be complex.
          return;
      }
      if (!levelStates[currentLevel]) {
          console.error("Cannot pronounce, level state missing.");
          return;
      }
       // Check if word data is ready
       const state = levelStates[currentLevel];
       const levelWordData = getLevelWords();
       if (!levelWordData || state.currentIndex < 0 || state.currentIndex >= levelWordData.length) {
           console.error("Word data not ready for pronunciation.");
           // Maybe briefly show feedback?
           showFeedback("Word not ready, please wait.", false);
           return;
       }


      console.log("Pronounce button clicked.");
      isSpeaking = true; // Set flag immediately
      disableButtons(); // Disable buttons while speaking
      pronounceSequence(); // Call the async sequence handler
    }

    // --- ASYNC PRONUNCIATION SEQUENCE HANDLER ---
    const pronounceSequence = async () => {
        const state = levelStates[currentLevel];
        // Ensure w and word are defined before use (robust check)
        if (!state || !state.wordIndices || state.indexPointer >= state.wordIndices.length) {
             console.error("Invalid state or index pointer in pronounceSequence.");
             isSpeaking = false; enableButtons(); return;
        }
        const levelWordData = getLevelWords(); // Use consistent naming
        // state.currentIndex should be set correctly by showWord or initialized state
         if (state.currentIndex < 0 || state.currentIndex >= levelWordData.length) {
             console.error("Invalid current index in pronounceSequence:", state.currentIndex);
             isSpeaking = false; enableButtons(); return;
         }
        const w = levelWordData[state.currentIndex];
         if (!w || !w.word) { // Check if word object and word itself exist
            console.error("Could not get valid word data in pronounceSequence.");
            isSpeaking = false; enableButtons(); return;
        }
        const word = w.word.toLowerCase();
        const runFullSequence = fullPronounceEnabled && state.currentIndex !== lastPronouncedIndex;

        try {
            // --- Pronunciation Attempt 1: Howjsay or TTS Fallback ---
            console.log("Attempting Howjsay audio (Attempt 1)...");
            try {
                await playHowjsayAudio(); // Try playing Howjsay
                console.log("Howjsay audio played successfully.");
            } catch (err) {
                // If Howjsay fails, play TTS as the first sound instead
                console.warn("Howjsay failed, using TTS for Attempt 1:", err);
                await speakText(word);
            }

            // Optional short pause to ensure first sound finishes or context switches
            await new Promise(resolve => setTimeout(resolve, 250)); // Adjust timing (e.g., 200-500ms)

            // --- Pronunciation Attempt 2: Always TTS ---
            console.log("Playing TTS audio (Attempt 2)...");
            await speakText(word); // Always play TTS for the second sound

            // --- Optional Full Sequence Details ---
            if (runFullSequence) {
                // Pause before starting the detailed pronunciation
                await new Promise(resolve => setTimeout(resolve, 800)); // Longer pause before details

                console.log("Running full pronunciation sequence (details)...");
                // Ensure part and definition exist before speaking
                if(w.part) await speakText(`Part of speech: ${w.part}`);
                if(w.definition) await speakText(`Definition: ${w.definition}`);
                await new Promise(resolve => setTimeout(resolve, 500));
                await speakText("Please spell");
                await new Promise(resolve => setTimeout(resolve, 500));
                await speakText(word); // Final word repetition using TTS

                lastPronouncedIndex = state.currentIndex; // Update only after full sequence completes
                console.log("Full pronunciation sequence complete.");
            }

        } catch (error) {
            console.error("Pronunciation sequence encountered an error:", error);
            // Attempt one last TTS fallback just in case
            try {
                console.log("Attempting final TTS fallback due to sequence error.");
                await speakText(word);
            } catch (e) {
                console.error("Final TTS fallback also failed", e);
            }
        } finally {
            isSpeaking = false;
            enableButtons();
            console.log("Pronunciation sequence finished (finally block).");
        }
    };
    // --- End of pronounceSequence ---

    // --- Helper: Speak Text using SpeechSynthesis ---
    const speakText = (text) => {
         return new Promise((resolve, reject) => {
            if (!text || typeof text !== 'string' || text.trim() === "") {
                 console.warn("speakText called with invalid text.");
                 return resolve(); // Resolve successfully if nothing to speak
             }
             console.log(`TTS: Speaking "${text}"`);
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = "en-US";
            utterance.rate = 0.7; // Adjust rate if needed
            utterance.pitch = 0.7; // Adjust pitch if needed

             // Workaround for potential issues where onend doesn't fire reliably
             let ended = false;
             const handleEnd = () => {
                 if (ended) return;
                 ended = true;
                 console.log(`TTS: Finished "${text}"`);
                 resolve();
             };
             utterance.onend = handleEnd;
             // Add a timeout as a fallback for onend not firing
             setTimeout(() => {
                 if (!ended) {
                     console.warn(`TTS: Timeout waiting for onend for "${text}". Resolving anyway.`);
                     resolve();
                 }
             }, text.length * 150 + 1000); // Estimate time based on text length + buffer

            utterance.onerror = (event) => {
                console.error(`TTS Error: "${text}"`, event.error);
                reject(event.error);
            };

            try {
                 // Optional: Cancel previous speech? Might be needed depending on desired behavior.
                 // speechSynthesis.cancel();
                 speechSynthesis.speak(utterance);
             } catch (e) {
                 console.error("Error calling speechSynthesis.speak:", e);
                 reject(e);
            }
        });
    };

    // --- Helper: Play Howjsay Audio ---
    const playHowjsayAudio = () => {
        // Get current word dynamically inside this function
         if (!levelStates[currentLevel] || !levelStates[currentLevel].wordIndices) {
              return Promise.reject(new Error("Cannot play Howjsay: Level state not ready."));
         }
        const state = levelStates[currentLevel];
         const levelWordData = getLevelWords();
         if (state.currentIndex < 0 || state.currentIndex >= levelWordData.length) {
             return Promise.reject(new Error("Cannot play Howjsay: Invalid current index."));
         }
        const w = levelWordData[state.currentIndex];
         if (!w || !w.word) {
              return Promise.reject(new Error("Cannot play Howjsay: Invalid word data."));
         }
        const wordForAudio = w.word.toLowerCase().replace(/[^a-z]/g, ''); // Basic sanitization for URL
         if (!wordForAudio) {
             return Promise.reject(new Error("Cannot play Howjsay: Invalid word after sanitization."));
         }

        console.log(`Howjsay: Attempting "${wordForAudio}"`);
        const audio = new Audio(`https://howjsay.com/mp3/${wordForAudio}.mp3`);
        audio.volume = 0.7;
        let timeoutId = null; // Declare timeoutId here

        // Cleanup function to remove listeners and clear timeout
        const cleanup = () => {
            if (timeoutId) clearTimeout(timeoutId);
            audio.oncanplaythrough = null;
            audio.onerror = null;
            audio.onended = null;
            audio.src = ""; // Release resource
            audio.load(); // Abort loading?
        };

        return new Promise((resolve, reject) => {
            timeoutId = setTimeout(() => { // Assign timeoutId
                 console.error(`Howjsay Timeout: "${wordForAudio}"`);
                 cleanup(); // Use cleanup function
                 reject(new Error("Audio load timeout"));
             }, 3500); // Slightly longer timeout? 3.5s

            audio.oncanplaythrough = () => {
                console.log(`Howjsay CanPlay: "${wordForAudio}"`);
                audio.play()
                    .then(() => {
                         console.log(`Howjsay Play Initiated: "${wordForAudio}"`);
                         // Resolution happens in onended
                     })
                    .catch(err => {
                        console.error(`Howjsay Play Error: "${wordForAudio}"`, err);
                        cleanup(); // Use cleanup function
                        reject(err); // Reject the promise if play() fails
                    });
            };
            audio.onerror = (e) => {
                console.error(`Howjsay OnError: "${wordForAudio}"`, audio.error);
                cleanup(); // Use cleanup function
                reject(new Error(`Howjsay audio onerror`));
            };
            audio.onended = () => {
                console.log(`Howjsay Finished: "${wordForAudio}"`);
                cleanup(); // Use cleanup function
                resolve(); // Resolve the promise when audio finishes playing
            };

            // Explicitly load the audio
            audio.load();
        });
    };
    // --- End of pronunciation helpers ---


    function disableButtons() {
      document.getElementById("pronounce").disabled = true;
      document.getElementById("checkAnswer").disabled = true;
      document.getElementById("showAnswer").disabled = true; // Always disable show answer when speaking
      document.getElementById("levelSelect").disabled = true;
       // Disable keyboard keys
      document.querySelectorAll('.key').forEach(key => key.disabled = true);
    }

    function enableButtons() {
       if (!levelStates[currentLevel]) return; // Safety check
      const state = levelStates[currentLevel];
      document.getElementById("pronounce").disabled = false;
      document.getElementById("checkAnswer").disabled = false;
      // Only enable showAnswer if failCount condition met
      document.getElementById("showAnswer").disabled = state.failCount < 3;
      document.getElementById("levelSelect").disabled = false;
       // Enable keyboard keys
      document.querySelectorAll('.key').forEach(key => key.disabled = false);
    }

    // --- LEVEL/REVIEW MODE MANAGEMENT ---

    function endReviewMode(forceComplete = false) { // Add flag
        if (!levelStates[currentLevel]) return;

        console.log("Ending review mode / Completing level.");
        levelStates[currentLevel].isReviewMode = false; // Ensure review mode is off

        // Only increment completion if not forced (i.e., review was actually done or skipped because empty)
        if (!forceComplete || (levelStates[currentLevel].missedWords && levelStates[currentLevel].missedWords.length === 0)) {
             levelCompletions[currentLevel] = (levelCompletions[currentLevel] || 0) + 1;
        }

        saveGameState(); // Save completion count and state change
        updateLevelSelect(); // Update stars/trophies display
        showLevelComplete(); // Show completion animation/message
    }

    function showReviewMode() {
      if (!levelStates[currentLevel] || !levelStates[currentLevel].missedWords || levelStates[currentLevel].missedWords.length === 0) {
         console.log("No missed words to review or state missing, completing level.");
         endReviewMode(true); // Complete level directly
         return;
      }

      const state = levelStates[currentLevel];
      console.log("Showing review mode screen.");
      document.getElementById("mainContent").style.display = "none"; // Hide main game

      const reviewDiv = document.getElementById("review-mode");
       if (!reviewDiv) {
           console.error("Review mode container div not found!");
           return;
       }
       reviewDiv.innerHTML = ''; // Clear previous content
       reviewDiv.style.display = 'flex'; // Make it visible

       const wordListContainer = document.createElement("div"); // Container for buttons
      state.missedWords.forEach(w => {
        const btn = document.createElement("button");
        btn.className = "word-button";
        btn.innerText = w.word;
        // Optional: Add click handler to pronounce word?
        // btn.onclick = () => speakText(w.word);
        wordListContainer.appendChild(btn);
      });
      reviewDiv.appendChild(wordListContainer); // Add word buttons

      const redoBtn = document.createElement("button");
      redoBtn.className = "redo-button";
      redoBtn.innerText = `Redo ${state.missedWords.length} Missed Word(s)`;
      redoBtn.onclick = redoMissedWords;
      reviewDiv.appendChild(redoBtn); // Add redo button
    }

    function redoMissedWords() {
      console.log("Redo Missed Words button clicked!");
      const reviewDiv = document.getElementById("review-mode");
      if (reviewDiv) reviewDiv.style.display = 'none'; // Hide review screen
      document.getElementById("mainContent").style.display = "block"; // Show main game

      if (!levelStates[currentLevel] || !levelStates[currentLevel].missedWords || levelStates[currentLevel].missedWords.length === 0) {
          console.warn("Redo called but no missed words found. Should not happen.");
           // Go back to normal mode or complete level?
           if (levelStates[currentLevel]) levelStates[currentLevel].isReviewMode = false;
           showWord(); // Try showing the first word of the level again
          return;
      }

      const state = levelStates[currentLevel];
      state.isReviewMode = true; // Set flag
      state.wordsCompleted = 0; // Reset progress for review
      state.failCount = 0;
      isSpeaking = false;
      speechSynthesis.cancel();
      state.currentWord = "";
      // Re-initialize indices based on missedWords
      initializeWordIndices(currentLevel);

      // Check if indices were created - initializeWordIndices handles empty missedWords now
      if (state.wordIndices && state.wordIndices.length > 0) {
           showWord(); // Show the first review word
           enableButtons();
           saveGameState(); // Save the state entering review mode
      } else {
          console.log("Review initialization resulted in no indices (likely no missed words). Completing level.");
          endReviewMode(true); // Complete if review setup failed
      }
    }


    // --- CELEBRATION & COMPLETION ANIMATIONS ---

    function showCelebration() {
      const celebration = document.getElementById("celebration");
      document.getElementById("mainContent").style.display = "none"; // Hide game temporarily
      celebration.style.display = "block";
      celebration.innerHTML = '<div class="celebration-text">ðŸŽ‰ Great Job! ðŸŽ‰</div>'; // Reset content

      const effectTypes = [0, 1, 2, 3]; // star, balloon, firework, confetti
      const effectsToUse = [];
      // Ensure at least one effect type is chosen
      while(effectsToUse.length === 0){
          if (Math.random() > 0.6) effectsToUse.push(0);
          if (Math.random() > 0.6) effectsToUse.push(1);
          if (Math.random() > 0.6) effectsToUse.push(2);
          if (Math.random() > 0.6) effectsToUse.push(3);
      }

      effectsToUse.forEach(effectType => {
          const count = effectType === 0 ? 10 : effectType === 1 ? 8 : effectType === 2 ? 15 : 20; // Adjust counts
        for (let i = 0; i < count; i++) {
          const el = document.createElement("div");
          el.style.left = `${Math.random() * 100}%`;
          el.style.top = `${Math.random() * 100}%`;
          el.style.animationDelay = `${Math.random() * 0.5}s`;
          const color = `hsl(${Math.random() * 360}, 90%, 70%)`; // Brighter random colors

          if (effectType === 0) el.className = "star";
          else if (effectType === 1) el.className = "balloon";
          else if (effectType === 2) el.className = "firework";
          else el.className = "confetti";

          // Apply color differently based on type
          if (effectType === 0 || effectType === 2) el.style.background = color; // Stars, Fireworks
          else if (effectType === 1) el.style.background = color; // Balloons
          else el.style.background = color; // Confetti

          celebration.appendChild(el);
        }
      });

      setTimeout(hideCelebration, 2000); // Celebration duration
    }

    function hideCelebration() {
      const celebration = document.getElementById("celebration");
      celebration.style.display = "none";
      document.getElementById("mainContent").style.display = "block"; // Show game again
      // Clear effects for next time
      celebration.innerHTML = '<div class="celebration-text">ðŸŽ‰ Great Job! ðŸŽ‰</div>';
      nextWord(); // Move to the next word *after* celebration hides
    }

    function showLevelComplete() {
      const levelComplete = document.getElementById("level-complete");
      document.getElementById("mainContent").style.display = "none"; // Hide game
      levelComplete.style.display = "block";
       levelComplete.innerHTML = '<div class="level-complete-text"><span>ðŸŽ‰ Level Complete! ðŸŽ‰</span><span></span></div>'; // Reset

      playSound('levelComplete');

       const levelCompleteTextContainer = levelComplete.querySelector(".level-complete-text"); // Re-select after innerHTML reset
       const levelCompleteTextSpan = levelCompleteTextContainer.children[1]; // Get the second span


       // Fixed base options array matching dropdown values 0-20
       const baseOptions = [
         "Level 1-a", "Level 1-b", "Level 1-c", "Level 1-d", "Level 1-e", // 0-4
         "Level 2-a", "Level 2-b", "Level 2-c", "Level 2-d", "Level 2-e", // 5-9
         "Level 3-a", "Level 3-b", "Level 3-c", "Level 3-d", "Level 3-e", // 10-14
         "Level 4", "Level 5", "Level 6", "Level 7", "Level 8", "Level 9"  // 15-20
       ];

      const completions = levelCompletions[currentLevel] || 0;
      const stars = completions % 5;
      const trophies = Math.floor(completions / 5);
      const nextLevelIndex = (currentLevel + 1) % baseOptions.length; // Loop back to level 0 after last level
      const nextLevelName = baseOptions[nextLevelIndex];

      let message = `You now have `;
       if (trophies > 0) message += `${trophies} ðŸ† `;
       if (stars > 0) message += `${stars} â­`;
       if (trophies === 0 && stars === 0 && completions === 1) { // Special message for first star only if no trophies yet
           message = "You earned your first â­!";
       } else if (trophies === 0 && stars === 0) { // Case where completion was forced but no stars/trophies
           message = "Level finished!";
       }
      message += `<br>Next up: ${nextLevelName}`;

      levelCompleteTextSpan.innerHTML = message; // Set the message

      updateLevelSelect(); // Update dropdown immediately

      // Add confetti/stars effect
      for (let i = 0; i < 30; i++) { // More effects for level complete
        const el = document.createElement("div");
        el.style.left = `${Math.random() * 100}%`;
        el.style.top = `${Math.random() * 100}%`;
        el.style.animationDelay = `${Math.random() * 1.5}s`;
        const type = Math.floor(Math.random() * 4);
        const color = `hsl(${Math.random() * 360}, 90%, 70%)`;

        if (type === 0) el.className = "star"; else el.className = "confetti"; // Stars and confetti mostly
        el.style.background = color;
        levelComplete.appendChild(el);
      }
      setTimeout(hideLevelComplete, 4000); // Duration of level complete screen
    }

    function hideLevelComplete() {
      const levelComplete = document.getElementById("level-complete");
      levelComplete.style.display = "none";
       levelComplete.innerHTML = '<div class="level-complete-text"><span>ðŸŽ‰ Level Complete! ðŸŽ‰</span><span></span></div>'; // Clear effects

        // --- Transition to Next Level ---
        // Delete state for the completed level to force re-initialization
        // Or just reset parts of it? Resetting ensures fresh shuffle.
       delete levelStates[currentLevel]; // Remove completed level state
       localStorage.removeItem(`levelState_${currentLevel}`); // Remove from storage too

       // Determine next level index, looping back to 0
       const numLevels = document.getElementById("levelSelect").options.length;
       currentLevel = (currentLevel + 1) % numLevels;

       localStorage.setItem('currentLevel', currentLevel); // Save new current level
       document.getElementById("levelSelect").value = currentLevel; // Update dropdown selection

       // Initialize state for the *new* current level
       initializeLevelState(currentLevel);

       // Show the first word of the new level
       showWord();
       // saveGameState(); // Save state is handled within initializeLevelState/showWord now
    }

    // --- KEYBOARD INPUT ---

    function appendLetter(letter) {
      if (!levelStates[currentLevel]) return;
      levelStates[currentLevel].currentWord += letter;
      updateDisplay();
      // No need to save state on every letter press
    }

    function removeLetter() {
      if (!levelStates[currentLevel]) return;
      levelStates[currentLevel].currentWord = levelStates[currentLevel].currentWord.slice(0, -1);
      updateDisplay();
    }

    function clearWord() {
      if (!levelStates[currentLevel]) return;
      levelStates[currentLevel].currentWord = "";
      updateDisplay();
    }

    function setupKeyboard() {
      console.log("Setting up keyboard...");
      const keyboard = document.getElementById("keyboard");
      keyboard.innerHTML = ''; // Clear existing keys if any
      const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      letters.forEach(letter => {
        const btn = document.createElement("button");
        btn.className = "key";
        btn.innerText = letter;
        btn.onclick = () => appendLetter(letter.toLowerCase());
        keyboard.appendChild(btn);
      });
      const backspace = document.createElement("button");
      backspace.id = "backspace";
      backspace.className = "key";
      backspace.innerText = "Back";
      backspace.onclick = removeLetter;
      keyboard.appendChild(backspace);
      const clear = document.createElement("button");
      clear.id = "clear";
      clear.className = "key";
      clear.innerText = "Clear";
      clear.onclick = clearWord;
      keyboard.appendChild(clear);
      console.log("Keyboard setup complete.");
    }

    // --- POPUP & RESET LOGIC ---

    function showConfirmPopup() {
      document.getElementById("confirmPopup").style.display = "block";
    }

    function hideConfirmPopup() {
      document.getElementById("confirmPopup").style.display = "none";
    }

    function goToWordList() {
      saveGameState(); // Save before leaving
      window.location.href = 'wordlist.html'; // Ensure this file exists
    }

    function showResetConfirmPopup() {
        // Show password prompt first
      document.getElementById("passwordPopup").style.display = "block";
      currentPassword = ""; // Clear password state
      updatePasswordDisplay();
      document.getElementById("passwordFeedback").innerText = ""; // Clear feedback
    }

     function hidePasswordPopup() {
      document.getElementById("passwordPopup").style.display = "none";
      currentPassword = ""; // Clear password state
      updatePasswordDisplay();
      document.getElementById("passwordFeedback").innerText = ""; // Clear feedback
    }

     function appendPasswordDigit(digit) {
      if (currentPassword.length < 4) {
        currentPassword += digit;
        updatePasswordDisplay();
        document.getElementById("passwordFeedback").innerText = ""; // Clear feedback on new input
      }
    }

    function clearPassword() {
      currentPassword = "";
      updatePasswordDisplay();
      document.getElementById("passwordFeedback").innerText = "";
    }

    function updatePasswordDisplay() {
      const display = document.getElementById("passwordDisplay");
      display.innerText = "â€¢".repeat(currentPassword.length);
    }

    function checkPassword() {
      if (currentPassword === "0925") { // Hardcoded password
        hidePasswordPopup();
        document.getElementById("resetConfirmPopup").style.display = "block"; // Show actual reset options
      } else {
        const popup = document.getElementById("passwordPopup");
        const feedback = document.getElementById("passwordFeedback");
        feedback.innerText = "Wrong Password!";
        popup.classList.add("shake");
        // Clear password automatically after failed attempt
        currentPassword = "";
        updatePasswordDisplay();
        setTimeout(() => {
          popup.classList.remove("shake");
          // feedback.innerText = ""; // Keep feedback until next digit press
        }, 500); // Shorter shake duration
      }
    }

    function hideResetConfirmPopup() {
      document.getElementById("resetConfirmPopup").style.display = "none";
    }

    function resetAllProgress() {
      if (!confirm("Are you absolutely sure you want to reset ALL progress for ALL levels?")) {
         return;
      }
      console.log("Resetting all progress...");
      currentLevel = 0;
      levelStates = {};
      levelCompletions = {};
      localStorage.clear(); // Clears everything related to this domain! Be careful.
      // Or selectively remove items:
      // localStorage.removeItem('currentLevel');
      // localStorage.removeItem('levelCompletions');
      // localStorage.removeItem('fullPronounceEnabled');
      // for (let i = 0; i < 21; i++) { localStorage.removeItem(`levelState_${i}`); }

      document.getElementById("levelSelect").value = 0;
      initializeLevelState(0); // Initialize level 0 again
      updateLevelSelect(); // Update display
      showWord(); // Show first word
      // saveGameState(); // initializeLevelState saves
      hideResetConfirmPopup();
      alert("All progress has been reset.");
    }

    function resetCurrentLevel() {
       if (!confirm(`Are you sure you want to reset progress for the current level (${document.getElementById('levelSelect').selectedOptions[0].text.split(' ')[0]})?`)) {
           return;
       }
       console.log("Resetting current level:", currentLevel);
       if (levelStates[currentLevel]) {
            // Reset state but keep potentially missed words if user wants to restart review immediately?
            // For simplicity, just fully re-initialize
            initializeLevelState(currentLevel);
       } else {
           initializeLevelState(currentLevel); // Initialize if state was missing
       }
       // Reset completions for this level too? Usually yes.
       delete levelCompletions[currentLevel];
       saveGameState(); // Save removed completions
       updateLevelSelect(); // Update visuals

       showWord(); // Show first word of the reset level
       hideResetConfirmPopup();
       alert("Current level progress has been reset.");
    }

     function addStarToLevel() {
        if (!levelStates[currentLevel]) initializeLevelState(currentLevel); // Ensure state exists
        levelCompletions[currentLevel] = (levelCompletions[currentLevel] || 0) + 1;
        updateLevelSelect();
        saveGameState();
        hideResetConfirmPopup();
         console.log("Manually added star to level", currentLevel);
    }

     function removeStarFromLevel() {
        if (!levelStates[currentLevel] || !levelCompletions[currentLevel] || levelCompletions[currentLevel] === 0) {
            alert("No stars to remove from this level.");
            hideResetConfirmPopup();
            return;
        }
        levelCompletions[currentLevel] = Math.max(0, (levelCompletions[currentLevel] || 0) - 1);
        if (levelCompletions[currentLevel] === 0) {
             delete levelCompletions[currentLevel]; // Clean up if zero
        }
        updateLevelSelect();
        saveGameState();
        hideResetConfirmPopup();
         console.log("Manually removed star from level", currentLevel);
    }

    // --- EVENT LISTENERS & SHORTCUTS ---

    function togglePronounce() {
      fullPronounceEnabled = !fullPronounceEnabled;
      updatePronounceButton();
      saveGameState(); // Save the setting change
    }

    // Ctrl+Shift+Z hack
    function setupKeyboardShortcuts() {
      console.log("Setting up keyboard shortcuts...");
      document.addEventListener('keydown', (event) => {
        // Allow shortcut only if focus is not on input elements (like password field if added)
        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT' || document.activeElement.tagName === 'TEXTAREA') {
            return;
        }

        if (event.ctrlKey && event.shiftKey && (event.key === 'Z' || event.key === 'z')) {
          event.preventDefault(); // Prevent any default browser action
          console.log("Ctrl+Shift+Z pressed, isSpeaking:", isSpeaking, "currentLevel:", currentLevel);
          if (isSpeaking) {
            console.log("Shortcut blocked by isSpeaking");
            return;
          }
          if (!levelStates[currentLevel]) {
             console.log("Shortcut blocked: No level state"); return;
          }

          const state = levelStates[currentLevel];
          const levelWordData = getLevelWords();

          if (!state || !state.wordIndices || state.indexPointer >= state.wordIndices.length) {
            console.log("Invalid state or level complete for shortcut:", state);
            // alert("Cannot use shortcut: Game state not ready or level complete.");
            return;
          }
           if (state.currentIndex < 0 || state.currentIndex >= levelWordData.length) {
                console.log("Invalid current index for shortcut:", state.currentIndex); return;
           }
          const correctWord = levelWordData[state.currentIndex]?.word;

          if (!correctWord) {
            console.log("No word available for shortcut at currentIndex:", state.currentIndex);
            // alert("Cannot use shortcut: No word available.");
            return;
          }

          console.log("Shortcut activated: Setting word and checking.");
          state.currentWord = correctWord;
          updateDisplay();
          // Add a slight delay before checking to allow UI update?
          setTimeout(checkSpelling, 50);
        }
      });
      console.log("Keyboard shortcuts setup complete.");
    }

    // Mascot tap shortcut
    function setupMascotTap() {
        const mascot = document.getElementById("mascot");
        mascot.addEventListener('touchstart', (event) => {
             // Prevent triggering click if touch is used
            event.preventDefault();
            handleMascotInteraction();
        });
        // Also add click for desktop testing
        mascot.addEventListener('click', handleMascotInteraction);
    }

    function handleMascotInteraction() {
        tapCount++;
        clearTimeout(tapTimeout);
        tapTimeout = setTimeout(() => { tapCount = 0; }, 500); // Reset count after 500ms

        if (tapCount === 3) {
             console.log("Mascot triple tap detected.");
             if (isSpeaking) {
                 console.log("Mascot tap blocked by isSpeaking.");
                 tapCount = 0; // Reset count
                 return;
             }
             if (!levelStates[currentLevel]) { console.log("Mascot tap blocked: No level state"); tapCount = 0; return; }

             const state = levelStates[currentLevel];
             const levelWordData = getLevelWords();
             if (!state || !state.wordIndices || state.indexPointer >= state.wordIndices.length) { console.log("Mascot tap blocked: Invalid state/level complete"); tapCount = 0; return; }
             if (state.currentIndex < 0 || state.currentIndex >= levelWordData.length) { console.log("Mascot tap blocked: Invalid index"); tapCount = 0; return; }

             const correctWord = levelWordData[state.currentIndex]?.word;
             if (!correctWord) { console.log("Mascot tap blocked: No word data"); tapCount = 0; return; }

             console.log("Mascot shortcut: Setting word and checking.");
             state.currentWord = correctWord;
             updateDisplay();
             setTimeout(checkSpelling, 50); // Check after brief delay
             tapCount = 0; // Reset count immediately after activation
        }
    }

     // Button event listeners setup
     function setupButtons() {
       console.log("Setting up buttons...");
       document.getElementById("pronounce").onclick = pronounceWord;
       document.getElementById("checkAnswer").onclick = checkSpelling;
       document.getElementById("showAnswer").onclick = showAnswer;
       // These are already set via inline onclick in HTML, but could be set here too
       // document.getElementById("fullPronounce").onclick = togglePronounce;
       // document.getElementById("wordListButton").onclick = showConfirmPopup;
       // document.getElementById("levelSelect").onchange = changeLevel;
       console.log("Buttons setup complete.");
     }


    // --- INITIALIZATION ---

    function startGame() {
      console.log("---- Starting Game ----");
      // Ensure setup functions run only once if startGame is called multiple times
      if (document.getElementById('keyboard').children.length === 0) {
         setupKeyboard();
         setupButtons(); // Setup main game buttons
         setupKeyboardShortcuts();
         setupMascotTap();
      } else {
          console.log("Game appears already set up, skipping setup functions.");
      }

      loadGameState(); // Load progress, sets currentLevel

      // Ensure state for the loaded currentLevel is valid before showing word
      if (!levelStates[currentLevel]) {
         console.warn(`No state found for loaded level ${currentLevel}. Initializing.`);
         initializeLevelState(currentLevel);
      }

      // Final check before showing word
      if (levelStates[currentLevel] && levelStates[currentLevel].wordIndices && levelStates[currentLevel].wordIndices.length > 0) {
          showWord(); // Display the first word
      } else {
          console.error("Game start failed: Could not prepare word list for level", currentLevel);
          // Maybe show an error message to the user here?
          alert("Error starting the game. Could not load words for the current level. Please try refreshing or selecting a different level.");
          document.getElementById("mainContent").style.display = "none"; // Hide broken game area
      }
      console.log("---- Game Started ----");
    }

    // --- DOMContentLoaded Listener (Entry Point) ---
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOM content loaded.");
      // Use the correct script name VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV
      const wordsScript = document.querySelector('script[src="https://geniusjazz.github.io/spelling-bee/words_full.js"]');
      // ^^^ Make sure this selector matches your actual script tag's src

      // Check if the global 'words' array is already defined (script might have loaded synchronously)
      if (typeof words !== 'undefined' && Array.isArray(words) && words.length > 0) {
        console.log("Global 'words' array found immediately:", words.length);
        startGame();
      } else if (wordsScript) { // Check if the script tag itself was found
        console.log("Waiting for words_full.js to load via script tag...");
        wordsScript.onload = () => {
          // Double-check 'words' is now available after onload event
          if (typeof words !== 'undefined' && Array.isArray(words) && words.length > 0) {
            console.log("words_full.js loaded successfully via onload:", words.length);
            startGame();
          } else {
            console.error("words_full.js onload fired, but 'words' array is still missing or invalid!");
            alert("Error: Word list loaded incorrectly. Please refresh.");
          }
        };
        wordsScript.onerror = () => {
          console.error("Failed to load words_full.js!");
          alert("Error: Could not load word list. Please check your internet connection and refresh the page.");
          // Optionally disable game controls here
           document.getElementById("mainContent").innerHTML = "<p style='color:red; font-weight:bold;'>Failed to load word list. Game cannot start.</p>";
        };

        // Fallback check in case onload doesn't fire or script loaded before listener attached
        setTimeout(() => {
            if (typeof words === 'undefined' || !Array.isArray(words) || words.length === 0) {
                console.warn("Still no 'words' array after 1 second. Script might have failed silently.");
                // Check if the game has somehow started anyway (unlikely)
                if (!document.getElementById('keyboard') || document.getElementById('keyboard').children.length === 0) {
                   // If game hasn't started, show error
                    // alert("Word list failed to load within timeout. Please refresh.");
                }
            } else if (!document.getElementById('keyboard') || document.getElementById('keyboard').children.length === 0) {
                 // Words loaded, but game didn't start? Try starting it.
                 console.log("Words found after delay, manually starting game.");
                 startGame();
             }
        }, 1000); // Check after 1 second

      } else {
        // This should not happen if the script tag is in the HTML
        console.error("Critical Error: Could not find the words_full.js script tag in the HTML!");
        alert("Critical Error: Word list script tag not found. Please check the HTML source.");
         document.getElementById("mainContent").innerHTML = "<p style='color:red; font-weight:bold;'>Word list script missing. Game cannot start.</p>";
      }
    });

  </script>
</body>
</html>
